// Code generated by counterfeiter. DO NOT EDIT.
package stanfakes

import (
	"sync"

	stan "github.com/nats-io/stan.go"
)

type FakeSubscription struct {
	ClearMaxPendingStub        func() error
	clearMaxPendingMutex       sync.RWMutex
	clearMaxPendingArgsForCall []struct {
	}
	clearMaxPendingReturns struct {
		result1 error
	}
	clearMaxPendingReturnsOnCall map[int]struct {
		result1 error
	}
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	DeliveredStub        func() (int64, error)
	deliveredMutex       sync.RWMutex
	deliveredArgsForCall []struct {
	}
	deliveredReturns struct {
		result1 int64
		result2 error
	}
	deliveredReturnsOnCall map[int]struct {
		result1 int64
		result2 error
	}
	DroppedStub        func() (int, error)
	droppedMutex       sync.RWMutex
	droppedArgsForCall []struct {
	}
	droppedReturns struct {
		result1 int
		result2 error
	}
	droppedReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	IsValidStub        func() bool
	isValidMutex       sync.RWMutex
	isValidArgsForCall []struct {
	}
	isValidReturns struct {
		result1 bool
	}
	isValidReturnsOnCall map[int]struct {
		result1 bool
	}
	MaxPendingStub        func() (int, int, error)
	maxPendingMutex       sync.RWMutex
	maxPendingArgsForCall []struct {
	}
	maxPendingReturns struct {
		result1 int
		result2 int
		result3 error
	}
	maxPendingReturnsOnCall map[int]struct {
		result1 int
		result2 int
		result3 error
	}
	PendingStub        func() (int, int, error)
	pendingMutex       sync.RWMutex
	pendingArgsForCall []struct {
	}
	pendingReturns struct {
		result1 int
		result2 int
		result3 error
	}
	pendingReturnsOnCall map[int]struct {
		result1 int
		result2 int
		result3 error
	}
	PendingLimitsStub        func() (int, int, error)
	pendingLimitsMutex       sync.RWMutex
	pendingLimitsArgsForCall []struct {
	}
	pendingLimitsReturns struct {
		result1 int
		result2 int
		result3 error
	}
	pendingLimitsReturnsOnCall map[int]struct {
		result1 int
		result2 int
		result3 error
	}
	SetPendingLimitsStub        func(int, int) error
	setPendingLimitsMutex       sync.RWMutex
	setPendingLimitsArgsForCall []struct {
		arg1 int
		arg2 int
	}
	setPendingLimitsReturns struct {
		result1 error
	}
	setPendingLimitsReturnsOnCall map[int]struct {
		result1 error
	}
	UnsubscribeStub        func() error
	unsubscribeMutex       sync.RWMutex
	unsubscribeArgsForCall []struct {
	}
	unsubscribeReturns struct {
		result1 error
	}
	unsubscribeReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSubscription) ClearMaxPending() error {
	fake.clearMaxPendingMutex.Lock()
	ret, specificReturn := fake.clearMaxPendingReturnsOnCall[len(fake.clearMaxPendingArgsForCall)]
	fake.clearMaxPendingArgsForCall = append(fake.clearMaxPendingArgsForCall, struct {
	}{})
	stub := fake.ClearMaxPendingStub
	fakeReturns := fake.clearMaxPendingReturns
	fake.recordInvocation("ClearMaxPending", []interface{}{})
	fake.clearMaxPendingMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSubscription) ClearMaxPendingCallCount() int {
	fake.clearMaxPendingMutex.RLock()
	defer fake.clearMaxPendingMutex.RUnlock()
	return len(fake.clearMaxPendingArgsForCall)
}

func (fake *FakeSubscription) ClearMaxPendingCalls(stub func() error) {
	fake.clearMaxPendingMutex.Lock()
	defer fake.clearMaxPendingMutex.Unlock()
	fake.ClearMaxPendingStub = stub
}

func (fake *FakeSubscription) ClearMaxPendingReturns(result1 error) {
	fake.clearMaxPendingMutex.Lock()
	defer fake.clearMaxPendingMutex.Unlock()
	fake.ClearMaxPendingStub = nil
	fake.clearMaxPendingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSubscription) ClearMaxPendingReturnsOnCall(i int, result1 error) {
	fake.clearMaxPendingMutex.Lock()
	defer fake.clearMaxPendingMutex.Unlock()
	fake.ClearMaxPendingStub = nil
	if fake.clearMaxPendingReturnsOnCall == nil {
		fake.clearMaxPendingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.clearMaxPendingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSubscription) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	stub := fake.CloseStub
	fakeReturns := fake.closeReturns
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSubscription) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeSubscription) CloseCalls(stub func() error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeSubscription) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSubscription) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSubscription) Delivered() (int64, error) {
	fake.deliveredMutex.Lock()
	ret, specificReturn := fake.deliveredReturnsOnCall[len(fake.deliveredArgsForCall)]
	fake.deliveredArgsForCall = append(fake.deliveredArgsForCall, struct {
	}{})
	stub := fake.DeliveredStub
	fakeReturns := fake.deliveredReturns
	fake.recordInvocation("Delivered", []interface{}{})
	fake.deliveredMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSubscription) DeliveredCallCount() int {
	fake.deliveredMutex.RLock()
	defer fake.deliveredMutex.RUnlock()
	return len(fake.deliveredArgsForCall)
}

func (fake *FakeSubscription) DeliveredCalls(stub func() (int64, error)) {
	fake.deliveredMutex.Lock()
	defer fake.deliveredMutex.Unlock()
	fake.DeliveredStub = stub
}

func (fake *FakeSubscription) DeliveredReturns(result1 int64, result2 error) {
	fake.deliveredMutex.Lock()
	defer fake.deliveredMutex.Unlock()
	fake.DeliveredStub = nil
	fake.deliveredReturns = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeSubscription) DeliveredReturnsOnCall(i int, result1 int64, result2 error) {
	fake.deliveredMutex.Lock()
	defer fake.deliveredMutex.Unlock()
	fake.DeliveredStub = nil
	if fake.deliveredReturnsOnCall == nil {
		fake.deliveredReturnsOnCall = make(map[int]struct {
			result1 int64
			result2 error
		})
	}
	fake.deliveredReturnsOnCall[i] = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeSubscription) Dropped() (int, error) {
	fake.droppedMutex.Lock()
	ret, specificReturn := fake.droppedReturnsOnCall[len(fake.droppedArgsForCall)]
	fake.droppedArgsForCall = append(fake.droppedArgsForCall, struct {
	}{})
	stub := fake.DroppedStub
	fakeReturns := fake.droppedReturns
	fake.recordInvocation("Dropped", []interface{}{})
	fake.droppedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSubscription) DroppedCallCount() int {
	fake.droppedMutex.RLock()
	defer fake.droppedMutex.RUnlock()
	return len(fake.droppedArgsForCall)
}

func (fake *FakeSubscription) DroppedCalls(stub func() (int, error)) {
	fake.droppedMutex.Lock()
	defer fake.droppedMutex.Unlock()
	fake.DroppedStub = stub
}

func (fake *FakeSubscription) DroppedReturns(result1 int, result2 error) {
	fake.droppedMutex.Lock()
	defer fake.droppedMutex.Unlock()
	fake.DroppedStub = nil
	fake.droppedReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSubscription) DroppedReturnsOnCall(i int, result1 int, result2 error) {
	fake.droppedMutex.Lock()
	defer fake.droppedMutex.Unlock()
	fake.DroppedStub = nil
	if fake.droppedReturnsOnCall == nil {
		fake.droppedReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.droppedReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeSubscription) IsValid() bool {
	fake.isValidMutex.Lock()
	ret, specificReturn := fake.isValidReturnsOnCall[len(fake.isValidArgsForCall)]
	fake.isValidArgsForCall = append(fake.isValidArgsForCall, struct {
	}{})
	stub := fake.IsValidStub
	fakeReturns := fake.isValidReturns
	fake.recordInvocation("IsValid", []interface{}{})
	fake.isValidMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSubscription) IsValidCallCount() int {
	fake.isValidMutex.RLock()
	defer fake.isValidMutex.RUnlock()
	return len(fake.isValidArgsForCall)
}

func (fake *FakeSubscription) IsValidCalls(stub func() bool) {
	fake.isValidMutex.Lock()
	defer fake.isValidMutex.Unlock()
	fake.IsValidStub = stub
}

func (fake *FakeSubscription) IsValidReturns(result1 bool) {
	fake.isValidMutex.Lock()
	defer fake.isValidMutex.Unlock()
	fake.IsValidStub = nil
	fake.isValidReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeSubscription) IsValidReturnsOnCall(i int, result1 bool) {
	fake.isValidMutex.Lock()
	defer fake.isValidMutex.Unlock()
	fake.IsValidStub = nil
	if fake.isValidReturnsOnCall == nil {
		fake.isValidReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isValidReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeSubscription) MaxPending() (int, int, error) {
	fake.maxPendingMutex.Lock()
	ret, specificReturn := fake.maxPendingReturnsOnCall[len(fake.maxPendingArgsForCall)]
	fake.maxPendingArgsForCall = append(fake.maxPendingArgsForCall, struct {
	}{})
	stub := fake.MaxPendingStub
	fakeReturns := fake.maxPendingReturns
	fake.recordInvocation("MaxPending", []interface{}{})
	fake.maxPendingMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeSubscription) MaxPendingCallCount() int {
	fake.maxPendingMutex.RLock()
	defer fake.maxPendingMutex.RUnlock()
	return len(fake.maxPendingArgsForCall)
}

func (fake *FakeSubscription) MaxPendingCalls(stub func() (int, int, error)) {
	fake.maxPendingMutex.Lock()
	defer fake.maxPendingMutex.Unlock()
	fake.MaxPendingStub = stub
}

func (fake *FakeSubscription) MaxPendingReturns(result1 int, result2 int, result3 error) {
	fake.maxPendingMutex.Lock()
	defer fake.maxPendingMutex.Unlock()
	fake.MaxPendingStub = nil
	fake.maxPendingReturns = struct {
		result1 int
		result2 int
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSubscription) MaxPendingReturnsOnCall(i int, result1 int, result2 int, result3 error) {
	fake.maxPendingMutex.Lock()
	defer fake.maxPendingMutex.Unlock()
	fake.MaxPendingStub = nil
	if fake.maxPendingReturnsOnCall == nil {
		fake.maxPendingReturnsOnCall = make(map[int]struct {
			result1 int
			result2 int
			result3 error
		})
	}
	fake.maxPendingReturnsOnCall[i] = struct {
		result1 int
		result2 int
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSubscription) Pending() (int, int, error) {
	fake.pendingMutex.Lock()
	ret, specificReturn := fake.pendingReturnsOnCall[len(fake.pendingArgsForCall)]
	fake.pendingArgsForCall = append(fake.pendingArgsForCall, struct {
	}{})
	stub := fake.PendingStub
	fakeReturns := fake.pendingReturns
	fake.recordInvocation("Pending", []interface{}{})
	fake.pendingMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeSubscription) PendingCallCount() int {
	fake.pendingMutex.RLock()
	defer fake.pendingMutex.RUnlock()
	return len(fake.pendingArgsForCall)
}

func (fake *FakeSubscription) PendingCalls(stub func() (int, int, error)) {
	fake.pendingMutex.Lock()
	defer fake.pendingMutex.Unlock()
	fake.PendingStub = stub
}

func (fake *FakeSubscription) PendingReturns(result1 int, result2 int, result3 error) {
	fake.pendingMutex.Lock()
	defer fake.pendingMutex.Unlock()
	fake.PendingStub = nil
	fake.pendingReturns = struct {
		result1 int
		result2 int
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSubscription) PendingReturnsOnCall(i int, result1 int, result2 int, result3 error) {
	fake.pendingMutex.Lock()
	defer fake.pendingMutex.Unlock()
	fake.PendingStub = nil
	if fake.pendingReturnsOnCall == nil {
		fake.pendingReturnsOnCall = make(map[int]struct {
			result1 int
			result2 int
			result3 error
		})
	}
	fake.pendingReturnsOnCall[i] = struct {
		result1 int
		result2 int
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSubscription) PendingLimits() (int, int, error) {
	fake.pendingLimitsMutex.Lock()
	ret, specificReturn := fake.pendingLimitsReturnsOnCall[len(fake.pendingLimitsArgsForCall)]
	fake.pendingLimitsArgsForCall = append(fake.pendingLimitsArgsForCall, struct {
	}{})
	stub := fake.PendingLimitsStub
	fakeReturns := fake.pendingLimitsReturns
	fake.recordInvocation("PendingLimits", []interface{}{})
	fake.pendingLimitsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeSubscription) PendingLimitsCallCount() int {
	fake.pendingLimitsMutex.RLock()
	defer fake.pendingLimitsMutex.RUnlock()
	return len(fake.pendingLimitsArgsForCall)
}

func (fake *FakeSubscription) PendingLimitsCalls(stub func() (int, int, error)) {
	fake.pendingLimitsMutex.Lock()
	defer fake.pendingLimitsMutex.Unlock()
	fake.PendingLimitsStub = stub
}

func (fake *FakeSubscription) PendingLimitsReturns(result1 int, result2 int, result3 error) {
	fake.pendingLimitsMutex.Lock()
	defer fake.pendingLimitsMutex.Unlock()
	fake.PendingLimitsStub = nil
	fake.pendingLimitsReturns = struct {
		result1 int
		result2 int
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSubscription) PendingLimitsReturnsOnCall(i int, result1 int, result2 int, result3 error) {
	fake.pendingLimitsMutex.Lock()
	defer fake.pendingLimitsMutex.Unlock()
	fake.PendingLimitsStub = nil
	if fake.pendingLimitsReturnsOnCall == nil {
		fake.pendingLimitsReturnsOnCall = make(map[int]struct {
			result1 int
			result2 int
			result3 error
		})
	}
	fake.pendingLimitsReturnsOnCall[i] = struct {
		result1 int
		result2 int
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeSubscription) SetPendingLimits(arg1 int, arg2 int) error {
	fake.setPendingLimitsMutex.Lock()
	ret, specificReturn := fake.setPendingLimitsReturnsOnCall[len(fake.setPendingLimitsArgsForCall)]
	fake.setPendingLimitsArgsForCall = append(fake.setPendingLimitsArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.SetPendingLimitsStub
	fakeReturns := fake.setPendingLimitsReturns
	fake.recordInvocation("SetPendingLimits", []interface{}{arg1, arg2})
	fake.setPendingLimitsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSubscription) SetPendingLimitsCallCount() int {
	fake.setPendingLimitsMutex.RLock()
	defer fake.setPendingLimitsMutex.RUnlock()
	return len(fake.setPendingLimitsArgsForCall)
}

func (fake *FakeSubscription) SetPendingLimitsCalls(stub func(int, int) error) {
	fake.setPendingLimitsMutex.Lock()
	defer fake.setPendingLimitsMutex.Unlock()
	fake.SetPendingLimitsStub = stub
}

func (fake *FakeSubscription) SetPendingLimitsArgsForCall(i int) (int, int) {
	fake.setPendingLimitsMutex.RLock()
	defer fake.setPendingLimitsMutex.RUnlock()
	argsForCall := fake.setPendingLimitsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSubscription) SetPendingLimitsReturns(result1 error) {
	fake.setPendingLimitsMutex.Lock()
	defer fake.setPendingLimitsMutex.Unlock()
	fake.SetPendingLimitsStub = nil
	fake.setPendingLimitsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSubscription) SetPendingLimitsReturnsOnCall(i int, result1 error) {
	fake.setPendingLimitsMutex.Lock()
	defer fake.setPendingLimitsMutex.Unlock()
	fake.SetPendingLimitsStub = nil
	if fake.setPendingLimitsReturnsOnCall == nil {
		fake.setPendingLimitsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setPendingLimitsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSubscription) Unsubscribe() error {
	fake.unsubscribeMutex.Lock()
	ret, specificReturn := fake.unsubscribeReturnsOnCall[len(fake.unsubscribeArgsForCall)]
	fake.unsubscribeArgsForCall = append(fake.unsubscribeArgsForCall, struct {
	}{})
	stub := fake.UnsubscribeStub
	fakeReturns := fake.unsubscribeReturns
	fake.recordInvocation("Unsubscribe", []interface{}{})
	fake.unsubscribeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSubscription) UnsubscribeCallCount() int {
	fake.unsubscribeMutex.RLock()
	defer fake.unsubscribeMutex.RUnlock()
	return len(fake.unsubscribeArgsForCall)
}

func (fake *FakeSubscription) UnsubscribeCalls(stub func() error) {
	fake.unsubscribeMutex.Lock()
	defer fake.unsubscribeMutex.Unlock()
	fake.UnsubscribeStub = stub
}

func (fake *FakeSubscription) UnsubscribeReturns(result1 error) {
	fake.unsubscribeMutex.Lock()
	defer fake.unsubscribeMutex.Unlock()
	fake.UnsubscribeStub = nil
	fake.unsubscribeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSubscription) UnsubscribeReturnsOnCall(i int, result1 error) {
	fake.unsubscribeMutex.Lock()
	defer fake.unsubscribeMutex.Unlock()
	fake.UnsubscribeStub = nil
	if fake.unsubscribeReturnsOnCall == nil {
		fake.unsubscribeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unsubscribeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSubscription) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.clearMaxPendingMutex.RLock()
	defer fake.clearMaxPendingMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.deliveredMutex.RLock()
	defer fake.deliveredMutex.RUnlock()
	fake.droppedMutex.RLock()
	defer fake.droppedMutex.RUnlock()
	fake.isValidMutex.RLock()
	defer fake.isValidMutex.RUnlock()
	fake.maxPendingMutex.RLock()
	defer fake.maxPendingMutex.RUnlock()
	fake.pendingMutex.RLock()
	defer fake.pendingMutex.RUnlock()
	fake.pendingLimitsMutex.RLock()
	defer fake.pendingLimitsMutex.RUnlock()
	fake.setPendingLimitsMutex.RLock()
	defer fake.setPendingLimitsMutex.RUnlock()
	fake.unsubscribeMutex.RLock()
	defer fake.unsubscribeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSubscription) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ stan.Subscription = new(FakeSubscription)
