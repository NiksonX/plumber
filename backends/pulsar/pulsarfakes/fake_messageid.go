// Code generated by counterfeiter. DO NOT EDIT.
package pulsarfakes

import (
	"sync"

	"github.com/apache/pulsar-client-go/pulsar"
)

type FakeMessageID struct {
	BatchIdxStub        func() int32
	batchIdxMutex       sync.RWMutex
	batchIdxArgsForCall []struct {
	}
	batchIdxReturns struct {
		result1 int32
	}
	batchIdxReturnsOnCall map[int]struct {
		result1 int32
	}
	EntryIDStub        func() int64
	entryIDMutex       sync.RWMutex
	entryIDArgsForCall []struct {
	}
	entryIDReturns struct {
		result1 int64
	}
	entryIDReturnsOnCall map[int]struct {
		result1 int64
	}
	LedgerIDStub        func() int64
	ledgerIDMutex       sync.RWMutex
	ledgerIDArgsForCall []struct {
	}
	ledgerIDReturns struct {
		result1 int64
	}
	ledgerIDReturnsOnCall map[int]struct {
		result1 int64
	}
	PartitionIdxStub        func() int32
	partitionIdxMutex       sync.RWMutex
	partitionIdxArgsForCall []struct {
	}
	partitionIdxReturns struct {
		result1 int32
	}
	partitionIdxReturnsOnCall map[int]struct {
		result1 int32
	}
	SerializeStub        func() []byte
	serializeMutex       sync.RWMutex
	serializeArgsForCall []struct {
	}
	serializeReturns struct {
		result1 []byte
	}
	serializeReturnsOnCall map[int]struct {
		result1 []byte
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeMessageID) BatchIdx() int32 {
	fake.batchIdxMutex.Lock()
	ret, specificReturn := fake.batchIdxReturnsOnCall[len(fake.batchIdxArgsForCall)]
	fake.batchIdxArgsForCall = append(fake.batchIdxArgsForCall, struct {
	}{})
	stub := fake.BatchIdxStub
	fakeReturns := fake.batchIdxReturns
	fake.recordInvocation("BatchIdx", []interface{}{})
	fake.batchIdxMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMessageID) BatchIdxCallCount() int {
	fake.batchIdxMutex.RLock()
	defer fake.batchIdxMutex.RUnlock()
	return len(fake.batchIdxArgsForCall)
}

func (fake *FakeMessageID) BatchIdxCalls(stub func() int32) {
	fake.batchIdxMutex.Lock()
	defer fake.batchIdxMutex.Unlock()
	fake.BatchIdxStub = stub
}

func (fake *FakeMessageID) BatchIdxReturns(result1 int32) {
	fake.batchIdxMutex.Lock()
	defer fake.batchIdxMutex.Unlock()
	fake.BatchIdxStub = nil
	fake.batchIdxReturns = struct {
		result1 int32
	}{result1}
}

func (fake *FakeMessageID) BatchIdxReturnsOnCall(i int, result1 int32) {
	fake.batchIdxMutex.Lock()
	defer fake.batchIdxMutex.Unlock()
	fake.BatchIdxStub = nil
	if fake.batchIdxReturnsOnCall == nil {
		fake.batchIdxReturnsOnCall = make(map[int]struct {
			result1 int32
		})
	}
	fake.batchIdxReturnsOnCall[i] = struct {
		result1 int32
	}{result1}
}

func (fake *FakeMessageID) EntryID() int64 {
	fake.entryIDMutex.Lock()
	ret, specificReturn := fake.entryIDReturnsOnCall[len(fake.entryIDArgsForCall)]
	fake.entryIDArgsForCall = append(fake.entryIDArgsForCall, struct {
	}{})
	stub := fake.EntryIDStub
	fakeReturns := fake.entryIDReturns
	fake.recordInvocation("EntryID", []interface{}{})
	fake.entryIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMessageID) EntryIDCallCount() int {
	fake.entryIDMutex.RLock()
	defer fake.entryIDMutex.RUnlock()
	return len(fake.entryIDArgsForCall)
}

func (fake *FakeMessageID) EntryIDCalls(stub func() int64) {
	fake.entryIDMutex.Lock()
	defer fake.entryIDMutex.Unlock()
	fake.EntryIDStub = stub
}

func (fake *FakeMessageID) EntryIDReturns(result1 int64) {
	fake.entryIDMutex.Lock()
	defer fake.entryIDMutex.Unlock()
	fake.EntryIDStub = nil
	fake.entryIDReturns = struct {
		result1 int64
	}{result1}
}

func (fake *FakeMessageID) EntryIDReturnsOnCall(i int, result1 int64) {
	fake.entryIDMutex.Lock()
	defer fake.entryIDMutex.Unlock()
	fake.EntryIDStub = nil
	if fake.entryIDReturnsOnCall == nil {
		fake.entryIDReturnsOnCall = make(map[int]struct {
			result1 int64
		})
	}
	fake.entryIDReturnsOnCall[i] = struct {
		result1 int64
	}{result1}
}

func (fake *FakeMessageID) LedgerID() int64 {
	fake.ledgerIDMutex.Lock()
	ret, specificReturn := fake.ledgerIDReturnsOnCall[len(fake.ledgerIDArgsForCall)]
	fake.ledgerIDArgsForCall = append(fake.ledgerIDArgsForCall, struct {
	}{})
	stub := fake.LedgerIDStub
	fakeReturns := fake.ledgerIDReturns
	fake.recordInvocation("LedgerID", []interface{}{})
	fake.ledgerIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMessageID) LedgerIDCallCount() int {
	fake.ledgerIDMutex.RLock()
	defer fake.ledgerIDMutex.RUnlock()
	return len(fake.ledgerIDArgsForCall)
}

func (fake *FakeMessageID) LedgerIDCalls(stub func() int64) {
	fake.ledgerIDMutex.Lock()
	defer fake.ledgerIDMutex.Unlock()
	fake.LedgerIDStub = stub
}

func (fake *FakeMessageID) LedgerIDReturns(result1 int64) {
	fake.ledgerIDMutex.Lock()
	defer fake.ledgerIDMutex.Unlock()
	fake.LedgerIDStub = nil
	fake.ledgerIDReturns = struct {
		result1 int64
	}{result1}
}

func (fake *FakeMessageID) LedgerIDReturnsOnCall(i int, result1 int64) {
	fake.ledgerIDMutex.Lock()
	defer fake.ledgerIDMutex.Unlock()
	fake.LedgerIDStub = nil
	if fake.ledgerIDReturnsOnCall == nil {
		fake.ledgerIDReturnsOnCall = make(map[int]struct {
			result1 int64
		})
	}
	fake.ledgerIDReturnsOnCall[i] = struct {
		result1 int64
	}{result1}
}

func (fake *FakeMessageID) PartitionIdx() int32 {
	fake.partitionIdxMutex.Lock()
	ret, specificReturn := fake.partitionIdxReturnsOnCall[len(fake.partitionIdxArgsForCall)]
	fake.partitionIdxArgsForCall = append(fake.partitionIdxArgsForCall, struct {
	}{})
	stub := fake.PartitionIdxStub
	fakeReturns := fake.partitionIdxReturns
	fake.recordInvocation("PartitionIdx", []interface{}{})
	fake.partitionIdxMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMessageID) PartitionIdxCallCount() int {
	fake.partitionIdxMutex.RLock()
	defer fake.partitionIdxMutex.RUnlock()
	return len(fake.partitionIdxArgsForCall)
}

func (fake *FakeMessageID) PartitionIdxCalls(stub func() int32) {
	fake.partitionIdxMutex.Lock()
	defer fake.partitionIdxMutex.Unlock()
	fake.PartitionIdxStub = stub
}

func (fake *FakeMessageID) PartitionIdxReturns(result1 int32) {
	fake.partitionIdxMutex.Lock()
	defer fake.partitionIdxMutex.Unlock()
	fake.PartitionIdxStub = nil
	fake.partitionIdxReturns = struct {
		result1 int32
	}{result1}
}

func (fake *FakeMessageID) PartitionIdxReturnsOnCall(i int, result1 int32) {
	fake.partitionIdxMutex.Lock()
	defer fake.partitionIdxMutex.Unlock()
	fake.PartitionIdxStub = nil
	if fake.partitionIdxReturnsOnCall == nil {
		fake.partitionIdxReturnsOnCall = make(map[int]struct {
			result1 int32
		})
	}
	fake.partitionIdxReturnsOnCall[i] = struct {
		result1 int32
	}{result1}
}

func (fake *FakeMessageID) Serialize() []byte {
	fake.serializeMutex.Lock()
	ret, specificReturn := fake.serializeReturnsOnCall[len(fake.serializeArgsForCall)]
	fake.serializeArgsForCall = append(fake.serializeArgsForCall, struct {
	}{})
	stub := fake.SerializeStub
	fakeReturns := fake.serializeReturns
	fake.recordInvocation("Serialize", []interface{}{})
	fake.serializeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMessageID) SerializeCallCount() int {
	fake.serializeMutex.RLock()
	defer fake.serializeMutex.RUnlock()
	return len(fake.serializeArgsForCall)
}

func (fake *FakeMessageID) SerializeCalls(stub func() []byte) {
	fake.serializeMutex.Lock()
	defer fake.serializeMutex.Unlock()
	fake.SerializeStub = stub
}

func (fake *FakeMessageID) SerializeReturns(result1 []byte) {
	fake.serializeMutex.Lock()
	defer fake.serializeMutex.Unlock()
	fake.SerializeStub = nil
	fake.serializeReturns = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeMessageID) SerializeReturnsOnCall(i int, result1 []byte) {
	fake.serializeMutex.Lock()
	defer fake.serializeMutex.Unlock()
	fake.SerializeStub = nil
	if fake.serializeReturnsOnCall == nil {
		fake.serializeReturnsOnCall = make(map[int]struct {
			result1 []byte
		})
	}
	fake.serializeReturnsOnCall[i] = struct {
		result1 []byte
	}{result1}
}

func (fake *FakeMessageID) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.batchIdxMutex.RLock()
	defer fake.batchIdxMutex.RUnlock()
	fake.entryIDMutex.RLock()
	defer fake.entryIDMutex.RUnlock()
	fake.ledgerIDMutex.RLock()
	defer fake.ledgerIDMutex.RUnlock()
	fake.partitionIdxMutex.RLock()
	defer fake.partitionIdxMutex.RUnlock()
	fake.serializeMutex.RLock()
	defer fake.serializeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeMessageID) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ pulsar.MessageID = new(FakeMessageID)
