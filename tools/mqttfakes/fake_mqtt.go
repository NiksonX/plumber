// Code generated by counterfeiter. DO NOT EDIT.
package mqttfakes

import (
	"sync"

	mqtt "github.com/eclipse/paho.mqtt.golang"
)

type FakeClient struct {
	AddRouteStub        func(string, mqtt.MessageHandler)
	addRouteMutex       sync.RWMutex
	addRouteArgsForCall []struct {
		arg1 string
		arg2 mqtt.MessageHandler
	}
	ConnectStub        func() mqtt.Token
	connectMutex       sync.RWMutex
	connectArgsForCall []struct {
	}
	connectReturns struct {
		result1 mqtt.Token
	}
	connectReturnsOnCall map[int]struct {
		result1 mqtt.Token
	}
	DisconnectStub        func(uint)
	disconnectMutex       sync.RWMutex
	disconnectArgsForCall []struct {
		arg1 uint
	}
	IsConnectedStub        func() bool
	isConnectedMutex       sync.RWMutex
	isConnectedArgsForCall []struct {
	}
	isConnectedReturns struct {
		result1 bool
	}
	isConnectedReturnsOnCall map[int]struct {
		result1 bool
	}
	IsConnectionOpenStub        func() bool
	isConnectionOpenMutex       sync.RWMutex
	isConnectionOpenArgsForCall []struct {
	}
	isConnectionOpenReturns struct {
		result1 bool
	}
	isConnectionOpenReturnsOnCall map[int]struct {
		result1 bool
	}
	OptionsReaderStub        func() mqtt.ClientOptionsReader
	optionsReaderMutex       sync.RWMutex
	optionsReaderArgsForCall []struct {
	}
	optionsReaderReturns struct {
		result1 mqtt.ClientOptionsReader
	}
	optionsReaderReturnsOnCall map[int]struct {
		result1 mqtt.ClientOptionsReader
	}
	PublishStub        func(string, byte, bool, interface{}) mqtt.Token
	publishMutex       sync.RWMutex
	publishArgsForCall []struct {
		arg1 string
		arg2 byte
		arg3 bool
		arg4 interface{}
	}
	publishReturns struct {
		result1 mqtt.Token
	}
	publishReturnsOnCall map[int]struct {
		result1 mqtt.Token
	}
	SubscribeStub        func(string, byte, mqtt.MessageHandler) mqtt.Token
	subscribeMutex       sync.RWMutex
	subscribeArgsForCall []struct {
		arg1 string
		arg2 byte
		arg3 mqtt.MessageHandler
	}
	subscribeReturns struct {
		result1 mqtt.Token
	}
	subscribeReturnsOnCall map[int]struct {
		result1 mqtt.Token
	}
	SubscribeMultipleStub        func(map[string]byte, mqtt.MessageHandler) mqtt.Token
	subscribeMultipleMutex       sync.RWMutex
	subscribeMultipleArgsForCall []struct {
		arg1 map[string]byte
		arg2 mqtt.MessageHandler
	}
	subscribeMultipleReturns struct {
		result1 mqtt.Token
	}
	subscribeMultipleReturnsOnCall map[int]struct {
		result1 mqtt.Token
	}
	UnsubscribeStub        func(...string) mqtt.Token
	unsubscribeMutex       sync.RWMutex
	unsubscribeArgsForCall []struct {
		arg1 []string
	}
	unsubscribeReturns struct {
		result1 mqtt.Token
	}
	unsubscribeReturnsOnCall map[int]struct {
		result1 mqtt.Token
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) AddRoute(arg1 string, arg2 mqtt.MessageHandler) {
	fake.addRouteMutex.Lock()
	fake.addRouteArgsForCall = append(fake.addRouteArgsForCall, struct {
		arg1 string
		arg2 mqtt.MessageHandler
	}{arg1, arg2})
	stub := fake.AddRouteStub
	fake.recordInvocation("AddRoute", []interface{}{arg1, arg2})
	fake.addRouteMutex.Unlock()
	if stub != nil {
		fake.AddRouteStub(arg1, arg2)
	}
}

func (fake *FakeClient) AddRouteCallCount() int {
	fake.addRouteMutex.RLock()
	defer fake.addRouteMutex.RUnlock()
	return len(fake.addRouteArgsForCall)
}

func (fake *FakeClient) AddRouteCalls(stub func(string, mqtt.MessageHandler)) {
	fake.addRouteMutex.Lock()
	defer fake.addRouteMutex.Unlock()
	fake.AddRouteStub = stub
}

func (fake *FakeClient) AddRouteArgsForCall(i int) (string, mqtt.MessageHandler) {
	fake.addRouteMutex.RLock()
	defer fake.addRouteMutex.RUnlock()
	argsForCall := fake.addRouteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) Connect() mqtt.Token {
	fake.connectMutex.Lock()
	ret, specificReturn := fake.connectReturnsOnCall[len(fake.connectArgsForCall)]
	fake.connectArgsForCall = append(fake.connectArgsForCall, struct {
	}{})
	stub := fake.ConnectStub
	fakeReturns := fake.connectReturns
	fake.recordInvocation("Connect", []interface{}{})
	fake.connectMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ConnectCallCount() int {
	fake.connectMutex.RLock()
	defer fake.connectMutex.RUnlock()
	return len(fake.connectArgsForCall)
}

func (fake *FakeClient) ConnectCalls(stub func() mqtt.Token) {
	fake.connectMutex.Lock()
	defer fake.connectMutex.Unlock()
	fake.ConnectStub = stub
}

func (fake *FakeClient) ConnectReturns(result1 mqtt.Token) {
	fake.connectMutex.Lock()
	defer fake.connectMutex.Unlock()
	fake.ConnectStub = nil
	fake.connectReturns = struct {
		result1 mqtt.Token
	}{result1}
}

func (fake *FakeClient) ConnectReturnsOnCall(i int, result1 mqtt.Token) {
	fake.connectMutex.Lock()
	defer fake.connectMutex.Unlock()
	fake.ConnectStub = nil
	if fake.connectReturnsOnCall == nil {
		fake.connectReturnsOnCall = make(map[int]struct {
			result1 mqtt.Token
		})
	}
	fake.connectReturnsOnCall[i] = struct {
		result1 mqtt.Token
	}{result1}
}

func (fake *FakeClient) Disconnect(arg1 uint) {
	fake.disconnectMutex.Lock()
	fake.disconnectArgsForCall = append(fake.disconnectArgsForCall, struct {
		arg1 uint
	}{arg1})
	stub := fake.DisconnectStub
	fake.recordInvocation("Disconnect", []interface{}{arg1})
	fake.disconnectMutex.Unlock()
	if stub != nil {
		fake.DisconnectStub(arg1)
	}
}

func (fake *FakeClient) DisconnectCallCount() int {
	fake.disconnectMutex.RLock()
	defer fake.disconnectMutex.RUnlock()
	return len(fake.disconnectArgsForCall)
}

func (fake *FakeClient) DisconnectCalls(stub func(uint)) {
	fake.disconnectMutex.Lock()
	defer fake.disconnectMutex.Unlock()
	fake.DisconnectStub = stub
}

func (fake *FakeClient) DisconnectArgsForCall(i int) uint {
	fake.disconnectMutex.RLock()
	defer fake.disconnectMutex.RUnlock()
	argsForCall := fake.disconnectArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) IsConnected() bool {
	fake.isConnectedMutex.Lock()
	ret, specificReturn := fake.isConnectedReturnsOnCall[len(fake.isConnectedArgsForCall)]
	fake.isConnectedArgsForCall = append(fake.isConnectedArgsForCall, struct {
	}{})
	stub := fake.IsConnectedStub
	fakeReturns := fake.isConnectedReturns
	fake.recordInvocation("IsConnected", []interface{}{})
	fake.isConnectedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) IsConnectedCallCount() int {
	fake.isConnectedMutex.RLock()
	defer fake.isConnectedMutex.RUnlock()
	return len(fake.isConnectedArgsForCall)
}

func (fake *FakeClient) IsConnectedCalls(stub func() bool) {
	fake.isConnectedMutex.Lock()
	defer fake.isConnectedMutex.Unlock()
	fake.IsConnectedStub = stub
}

func (fake *FakeClient) IsConnectedReturns(result1 bool) {
	fake.isConnectedMutex.Lock()
	defer fake.isConnectedMutex.Unlock()
	fake.IsConnectedStub = nil
	fake.isConnectedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeClient) IsConnectedReturnsOnCall(i int, result1 bool) {
	fake.isConnectedMutex.Lock()
	defer fake.isConnectedMutex.Unlock()
	fake.IsConnectedStub = nil
	if fake.isConnectedReturnsOnCall == nil {
		fake.isConnectedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isConnectedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeClient) IsConnectionOpen() bool {
	fake.isConnectionOpenMutex.Lock()
	ret, specificReturn := fake.isConnectionOpenReturnsOnCall[len(fake.isConnectionOpenArgsForCall)]
	fake.isConnectionOpenArgsForCall = append(fake.isConnectionOpenArgsForCall, struct {
	}{})
	stub := fake.IsConnectionOpenStub
	fakeReturns := fake.isConnectionOpenReturns
	fake.recordInvocation("IsConnectionOpen", []interface{}{})
	fake.isConnectionOpenMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) IsConnectionOpenCallCount() int {
	fake.isConnectionOpenMutex.RLock()
	defer fake.isConnectionOpenMutex.RUnlock()
	return len(fake.isConnectionOpenArgsForCall)
}

func (fake *FakeClient) IsConnectionOpenCalls(stub func() bool) {
	fake.isConnectionOpenMutex.Lock()
	defer fake.isConnectionOpenMutex.Unlock()
	fake.IsConnectionOpenStub = stub
}

func (fake *FakeClient) IsConnectionOpenReturns(result1 bool) {
	fake.isConnectionOpenMutex.Lock()
	defer fake.isConnectionOpenMutex.Unlock()
	fake.IsConnectionOpenStub = nil
	fake.isConnectionOpenReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeClient) IsConnectionOpenReturnsOnCall(i int, result1 bool) {
	fake.isConnectionOpenMutex.Lock()
	defer fake.isConnectionOpenMutex.Unlock()
	fake.IsConnectionOpenStub = nil
	if fake.isConnectionOpenReturnsOnCall == nil {
		fake.isConnectionOpenReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isConnectionOpenReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeClient) OptionsReader() mqtt.ClientOptionsReader {
	fake.optionsReaderMutex.Lock()
	ret, specificReturn := fake.optionsReaderReturnsOnCall[len(fake.optionsReaderArgsForCall)]
	fake.optionsReaderArgsForCall = append(fake.optionsReaderArgsForCall, struct {
	}{})
	stub := fake.OptionsReaderStub
	fakeReturns := fake.optionsReaderReturns
	fake.recordInvocation("OptionsReader", []interface{}{})
	fake.optionsReaderMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) OptionsReaderCallCount() int {
	fake.optionsReaderMutex.RLock()
	defer fake.optionsReaderMutex.RUnlock()
	return len(fake.optionsReaderArgsForCall)
}

func (fake *FakeClient) OptionsReaderCalls(stub func() mqtt.ClientOptionsReader) {
	fake.optionsReaderMutex.Lock()
	defer fake.optionsReaderMutex.Unlock()
	fake.OptionsReaderStub = stub
}

func (fake *FakeClient) OptionsReaderReturns(result1 mqtt.ClientOptionsReader) {
	fake.optionsReaderMutex.Lock()
	defer fake.optionsReaderMutex.Unlock()
	fake.OptionsReaderStub = nil
	fake.optionsReaderReturns = struct {
		result1 mqtt.ClientOptionsReader
	}{result1}
}

func (fake *FakeClient) OptionsReaderReturnsOnCall(i int, result1 mqtt.ClientOptionsReader) {
	fake.optionsReaderMutex.Lock()
	defer fake.optionsReaderMutex.Unlock()
	fake.OptionsReaderStub = nil
	if fake.optionsReaderReturnsOnCall == nil {
		fake.optionsReaderReturnsOnCall = make(map[int]struct {
			result1 mqtt.ClientOptionsReader
		})
	}
	fake.optionsReaderReturnsOnCall[i] = struct {
		result1 mqtt.ClientOptionsReader
	}{result1}
}

func (fake *FakeClient) Publish(arg1 string, arg2 byte, arg3 bool, arg4 interface{}) mqtt.Token {
	fake.publishMutex.Lock()
	ret, specificReturn := fake.publishReturnsOnCall[len(fake.publishArgsForCall)]
	fake.publishArgsForCall = append(fake.publishArgsForCall, struct {
		arg1 string
		arg2 byte
		arg3 bool
		arg4 interface{}
	}{arg1, arg2, arg3, arg4})
	stub := fake.PublishStub
	fakeReturns := fake.publishReturns
	fake.recordInvocation("Publish", []interface{}{arg1, arg2, arg3, arg4})
	fake.publishMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) PublishCallCount() int {
	fake.publishMutex.RLock()
	defer fake.publishMutex.RUnlock()
	return len(fake.publishArgsForCall)
}

func (fake *FakeClient) PublishCalls(stub func(string, byte, bool, interface{}) mqtt.Token) {
	fake.publishMutex.Lock()
	defer fake.publishMutex.Unlock()
	fake.PublishStub = stub
}

func (fake *FakeClient) PublishArgsForCall(i int) (string, byte, bool, interface{}) {
	fake.publishMutex.RLock()
	defer fake.publishMutex.RUnlock()
	argsForCall := fake.publishArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeClient) PublishReturns(result1 mqtt.Token) {
	fake.publishMutex.Lock()
	defer fake.publishMutex.Unlock()
	fake.PublishStub = nil
	fake.publishReturns = struct {
		result1 mqtt.Token
	}{result1}
}

func (fake *FakeClient) PublishReturnsOnCall(i int, result1 mqtt.Token) {
	fake.publishMutex.Lock()
	defer fake.publishMutex.Unlock()
	fake.PublishStub = nil
	if fake.publishReturnsOnCall == nil {
		fake.publishReturnsOnCall = make(map[int]struct {
			result1 mqtt.Token
		})
	}
	fake.publishReturnsOnCall[i] = struct {
		result1 mqtt.Token
	}{result1}
}

func (fake *FakeClient) Subscribe(arg1 string, arg2 byte, arg3 mqtt.MessageHandler) mqtt.Token {
	fake.subscribeMutex.Lock()
	ret, specificReturn := fake.subscribeReturnsOnCall[len(fake.subscribeArgsForCall)]
	fake.subscribeArgsForCall = append(fake.subscribeArgsForCall, struct {
		arg1 string
		arg2 byte
		arg3 mqtt.MessageHandler
	}{arg1, arg2, arg3})
	stub := fake.SubscribeStub
	fakeReturns := fake.subscribeReturns
	fake.recordInvocation("Subscribe", []interface{}{arg1, arg2, arg3})
	fake.subscribeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SubscribeCallCount() int {
	fake.subscribeMutex.RLock()
	defer fake.subscribeMutex.RUnlock()
	return len(fake.subscribeArgsForCall)
}

func (fake *FakeClient) SubscribeCalls(stub func(string, byte, mqtt.MessageHandler) mqtt.Token) {
	fake.subscribeMutex.Lock()
	defer fake.subscribeMutex.Unlock()
	fake.SubscribeStub = stub
}

func (fake *FakeClient) SubscribeArgsForCall(i int) (string, byte, mqtt.MessageHandler) {
	fake.subscribeMutex.RLock()
	defer fake.subscribeMutex.RUnlock()
	argsForCall := fake.subscribeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) SubscribeReturns(result1 mqtt.Token) {
	fake.subscribeMutex.Lock()
	defer fake.subscribeMutex.Unlock()
	fake.SubscribeStub = nil
	fake.subscribeReturns = struct {
		result1 mqtt.Token
	}{result1}
}

func (fake *FakeClient) SubscribeReturnsOnCall(i int, result1 mqtt.Token) {
	fake.subscribeMutex.Lock()
	defer fake.subscribeMutex.Unlock()
	fake.SubscribeStub = nil
	if fake.subscribeReturnsOnCall == nil {
		fake.subscribeReturnsOnCall = make(map[int]struct {
			result1 mqtt.Token
		})
	}
	fake.subscribeReturnsOnCall[i] = struct {
		result1 mqtt.Token
	}{result1}
}

func (fake *FakeClient) SubscribeMultiple(arg1 map[string]byte, arg2 mqtt.MessageHandler) mqtt.Token {
	fake.subscribeMultipleMutex.Lock()
	ret, specificReturn := fake.subscribeMultipleReturnsOnCall[len(fake.subscribeMultipleArgsForCall)]
	fake.subscribeMultipleArgsForCall = append(fake.subscribeMultipleArgsForCall, struct {
		arg1 map[string]byte
		arg2 mqtt.MessageHandler
	}{arg1, arg2})
	stub := fake.SubscribeMultipleStub
	fakeReturns := fake.subscribeMultipleReturns
	fake.recordInvocation("SubscribeMultiple", []interface{}{arg1, arg2})
	fake.subscribeMultipleMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SubscribeMultipleCallCount() int {
	fake.subscribeMultipleMutex.RLock()
	defer fake.subscribeMultipleMutex.RUnlock()
	return len(fake.subscribeMultipleArgsForCall)
}

func (fake *FakeClient) SubscribeMultipleCalls(stub func(map[string]byte, mqtt.MessageHandler) mqtt.Token) {
	fake.subscribeMultipleMutex.Lock()
	defer fake.subscribeMultipleMutex.Unlock()
	fake.SubscribeMultipleStub = stub
}

func (fake *FakeClient) SubscribeMultipleArgsForCall(i int) (map[string]byte, mqtt.MessageHandler) {
	fake.subscribeMultipleMutex.RLock()
	defer fake.subscribeMultipleMutex.RUnlock()
	argsForCall := fake.subscribeMultipleArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) SubscribeMultipleReturns(result1 mqtt.Token) {
	fake.subscribeMultipleMutex.Lock()
	defer fake.subscribeMultipleMutex.Unlock()
	fake.SubscribeMultipleStub = nil
	fake.subscribeMultipleReturns = struct {
		result1 mqtt.Token
	}{result1}
}

func (fake *FakeClient) SubscribeMultipleReturnsOnCall(i int, result1 mqtt.Token) {
	fake.subscribeMultipleMutex.Lock()
	defer fake.subscribeMultipleMutex.Unlock()
	fake.SubscribeMultipleStub = nil
	if fake.subscribeMultipleReturnsOnCall == nil {
		fake.subscribeMultipleReturnsOnCall = make(map[int]struct {
			result1 mqtt.Token
		})
	}
	fake.subscribeMultipleReturnsOnCall[i] = struct {
		result1 mqtt.Token
	}{result1}
}

func (fake *FakeClient) Unsubscribe(arg1 ...string) mqtt.Token {
	fake.unsubscribeMutex.Lock()
	ret, specificReturn := fake.unsubscribeReturnsOnCall[len(fake.unsubscribeArgsForCall)]
	fake.unsubscribeArgsForCall = append(fake.unsubscribeArgsForCall, struct {
		arg1 []string
	}{arg1})
	stub := fake.UnsubscribeStub
	fakeReturns := fake.unsubscribeReturns
	fake.recordInvocation("Unsubscribe", []interface{}{arg1})
	fake.unsubscribeMutex.Unlock()
	if stub != nil {
		return stub(arg1...)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) UnsubscribeCallCount() int {
	fake.unsubscribeMutex.RLock()
	defer fake.unsubscribeMutex.RUnlock()
	return len(fake.unsubscribeArgsForCall)
}

func (fake *FakeClient) UnsubscribeCalls(stub func(...string) mqtt.Token) {
	fake.unsubscribeMutex.Lock()
	defer fake.unsubscribeMutex.Unlock()
	fake.UnsubscribeStub = stub
}

func (fake *FakeClient) UnsubscribeArgsForCall(i int) []string {
	fake.unsubscribeMutex.RLock()
	defer fake.unsubscribeMutex.RUnlock()
	argsForCall := fake.unsubscribeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) UnsubscribeReturns(result1 mqtt.Token) {
	fake.unsubscribeMutex.Lock()
	defer fake.unsubscribeMutex.Unlock()
	fake.UnsubscribeStub = nil
	fake.unsubscribeReturns = struct {
		result1 mqtt.Token
	}{result1}
}

func (fake *FakeClient) UnsubscribeReturnsOnCall(i int, result1 mqtt.Token) {
	fake.unsubscribeMutex.Lock()
	defer fake.unsubscribeMutex.Unlock()
	fake.UnsubscribeStub = nil
	if fake.unsubscribeReturnsOnCall == nil {
		fake.unsubscribeReturnsOnCall = make(map[int]struct {
			result1 mqtt.Token
		})
	}
	fake.unsubscribeReturnsOnCall[i] = struct {
		result1 mqtt.Token
	}{result1}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addRouteMutex.RLock()
	defer fake.addRouteMutex.RUnlock()
	fake.connectMutex.RLock()
	defer fake.connectMutex.RUnlock()
	fake.disconnectMutex.RLock()
	defer fake.disconnectMutex.RUnlock()
	fake.isConnectedMutex.RLock()
	defer fake.isConnectedMutex.RUnlock()
	fake.isConnectionOpenMutex.RLock()
	defer fake.isConnectionOpenMutex.RUnlock()
	fake.optionsReaderMutex.RLock()
	defer fake.optionsReaderMutex.RUnlock()
	fake.publishMutex.RLock()
	defer fake.publishMutex.RUnlock()
	fake.subscribeMutex.RLock()
	defer fake.subscribeMutex.RUnlock()
	fake.subscribeMultipleMutex.RLock()
	defer fake.subscribeMultipleMutex.RUnlock()
	fake.unsubscribeMutex.RLock()
	defer fake.unsubscribeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ mqtt.Client = new(FakeClient)
