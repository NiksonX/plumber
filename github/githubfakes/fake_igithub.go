// Code generated by counterfeiter. DO NOT EDIT.
package githubfakes

import (
	"context"
	"net/url"
	"sync"

	"github.com/batchcorp/plumber/github"
	githuba "github.com/google/go-github/v37/github"
)

type FakeIGithub struct {
	CreateBranchStub        func(context.Context, string, string, string, string, string) (*githuba.Reference, error)
	createBranchMutex       sync.RWMutex
	createBranchArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 string
	}
	createBranchReturns struct {
		result1 *githuba.Reference
		result2 error
	}
	createBranchReturnsOnCall map[int]struct {
		result1 *githuba.Reference
		result2 error
	}
	CreateCommitStub        func(context.Context, string, string, string, string, string, *githuba.Commit) (*githuba.Commit, error)
	createCommitMutex       sync.RWMutex
	createCommitArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 string
		arg7 *githuba.Commit
	}
	createCommitReturns struct {
		result1 *githuba.Commit
		result2 error
	}
	createCommitReturnsOnCall map[int]struct {
		result1 *githuba.Commit
		result2 error
	}
	CreatePullRequestStub        func(context.Context, string, string, string, *github.PullRequestOpts) (*githuba.PullRequest, error)
	createPullRequestMutex       sync.RWMutex
	createPullRequestArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 *github.PullRequestOpts
	}
	createPullRequestReturns struct {
		result1 *githuba.PullRequest
		result2 error
	}
	createPullRequestReturnsOnCall map[int]struct {
		result1 *githuba.PullRequest
		result2 error
	}
	CreateTreeStub        func(context.Context, string, string, string, string, []*githuba.TreeEntry) (*githuba.Tree, error)
	createTreeMutex       sync.RWMutex
	createTreeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 []*githuba.TreeEntry
	}
	createTreeReturns struct {
		result1 *githuba.Tree
		result2 error
	}
	createTreeReturnsOnCall map[int]struct {
		result1 *githuba.Tree
		result2 error
	}
	GetRepoArchiveStub        func(context.Context, string, string, string) ([]byte, error)
	getRepoArchiveMutex       sync.RWMutex
	getRepoArchiveArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	getRepoArchiveReturns struct {
		result1 []byte
		result2 error
	}
	getRepoArchiveReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	GetRepoFileStub        func(context.Context, string, string, string, string) ([]byte, error)
	getRepoFileMutex       sync.RWMutex
	getRepoFileArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
	}
	getRepoFileReturns struct {
		result1 []byte
		result2 error
	}
	getRepoFileReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	GetRepoListStub        func(context.Context, int64, string) ([]string, error)
	getRepoListMutex       sync.RWMutex
	getRepoListArgsForCall []struct {
		arg1 context.Context
		arg2 int64
		arg3 string
	}
	getRepoListReturns struct {
		result1 []string
		result2 error
	}
	getRepoListReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	GetRepoTreeStub        func(context.Context, string, string, string) (*githuba.Tree, error)
	getRepoTreeMutex       sync.RWMutex
	getRepoTreeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	getRepoTreeReturns struct {
		result1 *githuba.Tree
		result2 error
	}
	getRepoTreeReturnsOnCall map[int]struct {
		result1 *githuba.Tree
		result2 error
	}
	PostStub        func(string, url.Values) ([]byte, int, error)
	postMutex       sync.RWMutex
	postArgsForCall []struct {
		arg1 string
		arg2 url.Values
	}
	postReturns struct {
		result1 []byte
		result2 int
		result3 error
	}
	postReturnsOnCall map[int]struct {
		result1 []byte
		result2 int
		result3 error
	}
	UpdateBranchStub        func(context.Context, string, string, string, string, string) (*githuba.Reference, error)
	updateBranchMutex       sync.RWMutex
	updateBranchArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 string
	}
	updateBranchReturns struct {
		result1 *githuba.Reference
		result2 error
	}
	updateBranchReturnsOnCall map[int]struct {
		result1 *githuba.Reference
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeIGithub) CreateBranch(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 string, arg6 string) (*githuba.Reference, error) {
	fake.createBranchMutex.Lock()
	ret, specificReturn := fake.createBranchReturnsOnCall[len(fake.createBranchArgsForCall)]
	fake.createBranchArgsForCall = append(fake.createBranchArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 string
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.CreateBranchStub
	fakeReturns := fake.createBranchReturns
	fake.recordInvocation("CreateBranch", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.createBranchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGithub) CreateBranchCallCount() int {
	fake.createBranchMutex.RLock()
	defer fake.createBranchMutex.RUnlock()
	return len(fake.createBranchArgsForCall)
}

func (fake *FakeIGithub) CreateBranchCalls(stub func(context.Context, string, string, string, string, string) (*githuba.Reference, error)) {
	fake.createBranchMutex.Lock()
	defer fake.createBranchMutex.Unlock()
	fake.CreateBranchStub = stub
}

func (fake *FakeIGithub) CreateBranchArgsForCall(i int) (context.Context, string, string, string, string, string) {
	fake.createBranchMutex.RLock()
	defer fake.createBranchMutex.RUnlock()
	argsForCall := fake.createBranchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeIGithub) CreateBranchReturns(result1 *githuba.Reference, result2 error) {
	fake.createBranchMutex.Lock()
	defer fake.createBranchMutex.Unlock()
	fake.CreateBranchStub = nil
	fake.createBranchReturns = struct {
		result1 *githuba.Reference
		result2 error
	}{result1, result2}
}

func (fake *FakeIGithub) CreateBranchReturnsOnCall(i int, result1 *githuba.Reference, result2 error) {
	fake.createBranchMutex.Lock()
	defer fake.createBranchMutex.Unlock()
	fake.CreateBranchStub = nil
	if fake.createBranchReturnsOnCall == nil {
		fake.createBranchReturnsOnCall = make(map[int]struct {
			result1 *githuba.Reference
			result2 error
		})
	}
	fake.createBranchReturnsOnCall[i] = struct {
		result1 *githuba.Reference
		result2 error
	}{result1, result2}
}

func (fake *FakeIGithub) CreateCommit(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 string, arg6 string, arg7 *githuba.Commit) (*githuba.Commit, error) {
	fake.createCommitMutex.Lock()
	ret, specificReturn := fake.createCommitReturnsOnCall[len(fake.createCommitArgsForCall)]
	fake.createCommitArgsForCall = append(fake.createCommitArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 string
		arg7 *githuba.Commit
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	stub := fake.CreateCommitStub
	fakeReturns := fake.createCommitReturns
	fake.recordInvocation("CreateCommit", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.createCommitMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGithub) CreateCommitCallCount() int {
	fake.createCommitMutex.RLock()
	defer fake.createCommitMutex.RUnlock()
	return len(fake.createCommitArgsForCall)
}

func (fake *FakeIGithub) CreateCommitCalls(stub func(context.Context, string, string, string, string, string, *githuba.Commit) (*githuba.Commit, error)) {
	fake.createCommitMutex.Lock()
	defer fake.createCommitMutex.Unlock()
	fake.CreateCommitStub = stub
}

func (fake *FakeIGithub) CreateCommitArgsForCall(i int) (context.Context, string, string, string, string, string, *githuba.Commit) {
	fake.createCommitMutex.RLock()
	defer fake.createCommitMutex.RUnlock()
	argsForCall := fake.createCommitArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeIGithub) CreateCommitReturns(result1 *githuba.Commit, result2 error) {
	fake.createCommitMutex.Lock()
	defer fake.createCommitMutex.Unlock()
	fake.CreateCommitStub = nil
	fake.createCommitReturns = struct {
		result1 *githuba.Commit
		result2 error
	}{result1, result2}
}

func (fake *FakeIGithub) CreateCommitReturnsOnCall(i int, result1 *githuba.Commit, result2 error) {
	fake.createCommitMutex.Lock()
	defer fake.createCommitMutex.Unlock()
	fake.CreateCommitStub = nil
	if fake.createCommitReturnsOnCall == nil {
		fake.createCommitReturnsOnCall = make(map[int]struct {
			result1 *githuba.Commit
			result2 error
		})
	}
	fake.createCommitReturnsOnCall[i] = struct {
		result1 *githuba.Commit
		result2 error
	}{result1, result2}
}

func (fake *FakeIGithub) CreatePullRequest(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 *github.PullRequestOpts) (*githuba.PullRequest, error) {
	fake.createPullRequestMutex.Lock()
	ret, specificReturn := fake.createPullRequestReturnsOnCall[len(fake.createPullRequestArgsForCall)]
	fake.createPullRequestArgsForCall = append(fake.createPullRequestArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 *github.PullRequestOpts
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.CreatePullRequestStub
	fakeReturns := fake.createPullRequestReturns
	fake.recordInvocation("CreatePullRequest", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.createPullRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGithub) CreatePullRequestCallCount() int {
	fake.createPullRequestMutex.RLock()
	defer fake.createPullRequestMutex.RUnlock()
	return len(fake.createPullRequestArgsForCall)
}

func (fake *FakeIGithub) CreatePullRequestCalls(stub func(context.Context, string, string, string, *github.PullRequestOpts) (*githuba.PullRequest, error)) {
	fake.createPullRequestMutex.Lock()
	defer fake.createPullRequestMutex.Unlock()
	fake.CreatePullRequestStub = stub
}

func (fake *FakeIGithub) CreatePullRequestArgsForCall(i int) (context.Context, string, string, string, *github.PullRequestOpts) {
	fake.createPullRequestMutex.RLock()
	defer fake.createPullRequestMutex.RUnlock()
	argsForCall := fake.createPullRequestArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeIGithub) CreatePullRequestReturns(result1 *githuba.PullRequest, result2 error) {
	fake.createPullRequestMutex.Lock()
	defer fake.createPullRequestMutex.Unlock()
	fake.CreatePullRequestStub = nil
	fake.createPullRequestReturns = struct {
		result1 *githuba.PullRequest
		result2 error
	}{result1, result2}
}

func (fake *FakeIGithub) CreatePullRequestReturnsOnCall(i int, result1 *githuba.PullRequest, result2 error) {
	fake.createPullRequestMutex.Lock()
	defer fake.createPullRequestMutex.Unlock()
	fake.CreatePullRequestStub = nil
	if fake.createPullRequestReturnsOnCall == nil {
		fake.createPullRequestReturnsOnCall = make(map[int]struct {
			result1 *githuba.PullRequest
			result2 error
		})
	}
	fake.createPullRequestReturnsOnCall[i] = struct {
		result1 *githuba.PullRequest
		result2 error
	}{result1, result2}
}

func (fake *FakeIGithub) CreateTree(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 string, arg6 []*githuba.TreeEntry) (*githuba.Tree, error) {
	var arg6Copy []*githuba.TreeEntry
	if arg6 != nil {
		arg6Copy = make([]*githuba.TreeEntry, len(arg6))
		copy(arg6Copy, arg6)
	}
	fake.createTreeMutex.Lock()
	ret, specificReturn := fake.createTreeReturnsOnCall[len(fake.createTreeArgsForCall)]
	fake.createTreeArgsForCall = append(fake.createTreeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 []*githuba.TreeEntry
	}{arg1, arg2, arg3, arg4, arg5, arg6Copy})
	stub := fake.CreateTreeStub
	fakeReturns := fake.createTreeReturns
	fake.recordInvocation("CreateTree", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6Copy})
	fake.createTreeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGithub) CreateTreeCallCount() int {
	fake.createTreeMutex.RLock()
	defer fake.createTreeMutex.RUnlock()
	return len(fake.createTreeArgsForCall)
}

func (fake *FakeIGithub) CreateTreeCalls(stub func(context.Context, string, string, string, string, []*githuba.TreeEntry) (*githuba.Tree, error)) {
	fake.createTreeMutex.Lock()
	defer fake.createTreeMutex.Unlock()
	fake.CreateTreeStub = stub
}

func (fake *FakeIGithub) CreateTreeArgsForCall(i int) (context.Context, string, string, string, string, []*githuba.TreeEntry) {
	fake.createTreeMutex.RLock()
	defer fake.createTreeMutex.RUnlock()
	argsForCall := fake.createTreeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeIGithub) CreateTreeReturns(result1 *githuba.Tree, result2 error) {
	fake.createTreeMutex.Lock()
	defer fake.createTreeMutex.Unlock()
	fake.CreateTreeStub = nil
	fake.createTreeReturns = struct {
		result1 *githuba.Tree
		result2 error
	}{result1, result2}
}

func (fake *FakeIGithub) CreateTreeReturnsOnCall(i int, result1 *githuba.Tree, result2 error) {
	fake.createTreeMutex.Lock()
	defer fake.createTreeMutex.Unlock()
	fake.CreateTreeStub = nil
	if fake.createTreeReturnsOnCall == nil {
		fake.createTreeReturnsOnCall = make(map[int]struct {
			result1 *githuba.Tree
			result2 error
		})
	}
	fake.createTreeReturnsOnCall[i] = struct {
		result1 *githuba.Tree
		result2 error
	}{result1, result2}
}

func (fake *FakeIGithub) GetRepoArchive(arg1 context.Context, arg2 string, arg3 string, arg4 string) ([]byte, error) {
	fake.getRepoArchiveMutex.Lock()
	ret, specificReturn := fake.getRepoArchiveReturnsOnCall[len(fake.getRepoArchiveArgsForCall)]
	fake.getRepoArchiveArgsForCall = append(fake.getRepoArchiveArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetRepoArchiveStub
	fakeReturns := fake.getRepoArchiveReturns
	fake.recordInvocation("GetRepoArchive", []interface{}{arg1, arg2, arg3, arg4})
	fake.getRepoArchiveMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGithub) GetRepoArchiveCallCount() int {
	fake.getRepoArchiveMutex.RLock()
	defer fake.getRepoArchiveMutex.RUnlock()
	return len(fake.getRepoArchiveArgsForCall)
}

func (fake *FakeIGithub) GetRepoArchiveCalls(stub func(context.Context, string, string, string) ([]byte, error)) {
	fake.getRepoArchiveMutex.Lock()
	defer fake.getRepoArchiveMutex.Unlock()
	fake.GetRepoArchiveStub = stub
}

func (fake *FakeIGithub) GetRepoArchiveArgsForCall(i int) (context.Context, string, string, string) {
	fake.getRepoArchiveMutex.RLock()
	defer fake.getRepoArchiveMutex.RUnlock()
	argsForCall := fake.getRepoArchiveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeIGithub) GetRepoArchiveReturns(result1 []byte, result2 error) {
	fake.getRepoArchiveMutex.Lock()
	defer fake.getRepoArchiveMutex.Unlock()
	fake.GetRepoArchiveStub = nil
	fake.getRepoArchiveReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeIGithub) GetRepoArchiveReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.getRepoArchiveMutex.Lock()
	defer fake.getRepoArchiveMutex.Unlock()
	fake.GetRepoArchiveStub = nil
	if fake.getRepoArchiveReturnsOnCall == nil {
		fake.getRepoArchiveReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.getRepoArchiveReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeIGithub) GetRepoFile(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 string) ([]byte, error) {
	fake.getRepoFileMutex.Lock()
	ret, specificReturn := fake.getRepoFileReturnsOnCall[len(fake.getRepoFileArgsForCall)]
	fake.getRepoFileArgsForCall = append(fake.getRepoFileArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.GetRepoFileStub
	fakeReturns := fake.getRepoFileReturns
	fake.recordInvocation("GetRepoFile", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.getRepoFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGithub) GetRepoFileCallCount() int {
	fake.getRepoFileMutex.RLock()
	defer fake.getRepoFileMutex.RUnlock()
	return len(fake.getRepoFileArgsForCall)
}

func (fake *FakeIGithub) GetRepoFileCalls(stub func(context.Context, string, string, string, string) ([]byte, error)) {
	fake.getRepoFileMutex.Lock()
	defer fake.getRepoFileMutex.Unlock()
	fake.GetRepoFileStub = stub
}

func (fake *FakeIGithub) GetRepoFileArgsForCall(i int) (context.Context, string, string, string, string) {
	fake.getRepoFileMutex.RLock()
	defer fake.getRepoFileMutex.RUnlock()
	argsForCall := fake.getRepoFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeIGithub) GetRepoFileReturns(result1 []byte, result2 error) {
	fake.getRepoFileMutex.Lock()
	defer fake.getRepoFileMutex.Unlock()
	fake.GetRepoFileStub = nil
	fake.getRepoFileReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeIGithub) GetRepoFileReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.getRepoFileMutex.Lock()
	defer fake.getRepoFileMutex.Unlock()
	fake.GetRepoFileStub = nil
	if fake.getRepoFileReturnsOnCall == nil {
		fake.getRepoFileReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.getRepoFileReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeIGithub) GetRepoList(arg1 context.Context, arg2 int64, arg3 string) ([]string, error) {
	fake.getRepoListMutex.Lock()
	ret, specificReturn := fake.getRepoListReturnsOnCall[len(fake.getRepoListArgsForCall)]
	fake.getRepoListArgsForCall = append(fake.getRepoListArgsForCall, struct {
		arg1 context.Context
		arg2 int64
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.GetRepoListStub
	fakeReturns := fake.getRepoListReturns
	fake.recordInvocation("GetRepoList", []interface{}{arg1, arg2, arg3})
	fake.getRepoListMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGithub) GetRepoListCallCount() int {
	fake.getRepoListMutex.RLock()
	defer fake.getRepoListMutex.RUnlock()
	return len(fake.getRepoListArgsForCall)
}

func (fake *FakeIGithub) GetRepoListCalls(stub func(context.Context, int64, string) ([]string, error)) {
	fake.getRepoListMutex.Lock()
	defer fake.getRepoListMutex.Unlock()
	fake.GetRepoListStub = stub
}

func (fake *FakeIGithub) GetRepoListArgsForCall(i int) (context.Context, int64, string) {
	fake.getRepoListMutex.RLock()
	defer fake.getRepoListMutex.RUnlock()
	argsForCall := fake.getRepoListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIGithub) GetRepoListReturns(result1 []string, result2 error) {
	fake.getRepoListMutex.Lock()
	defer fake.getRepoListMutex.Unlock()
	fake.GetRepoListStub = nil
	fake.getRepoListReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeIGithub) GetRepoListReturnsOnCall(i int, result1 []string, result2 error) {
	fake.getRepoListMutex.Lock()
	defer fake.getRepoListMutex.Unlock()
	fake.GetRepoListStub = nil
	if fake.getRepoListReturnsOnCall == nil {
		fake.getRepoListReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.getRepoListReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeIGithub) GetRepoTree(arg1 context.Context, arg2 string, arg3 string, arg4 string) (*githuba.Tree, error) {
	fake.getRepoTreeMutex.Lock()
	ret, specificReturn := fake.getRepoTreeReturnsOnCall[len(fake.getRepoTreeArgsForCall)]
	fake.getRepoTreeArgsForCall = append(fake.getRepoTreeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.GetRepoTreeStub
	fakeReturns := fake.getRepoTreeReturns
	fake.recordInvocation("GetRepoTree", []interface{}{arg1, arg2, arg3, arg4})
	fake.getRepoTreeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGithub) GetRepoTreeCallCount() int {
	fake.getRepoTreeMutex.RLock()
	defer fake.getRepoTreeMutex.RUnlock()
	return len(fake.getRepoTreeArgsForCall)
}

func (fake *FakeIGithub) GetRepoTreeCalls(stub func(context.Context, string, string, string) (*githuba.Tree, error)) {
	fake.getRepoTreeMutex.Lock()
	defer fake.getRepoTreeMutex.Unlock()
	fake.GetRepoTreeStub = stub
}

func (fake *FakeIGithub) GetRepoTreeArgsForCall(i int) (context.Context, string, string, string) {
	fake.getRepoTreeMutex.RLock()
	defer fake.getRepoTreeMutex.RUnlock()
	argsForCall := fake.getRepoTreeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeIGithub) GetRepoTreeReturns(result1 *githuba.Tree, result2 error) {
	fake.getRepoTreeMutex.Lock()
	defer fake.getRepoTreeMutex.Unlock()
	fake.GetRepoTreeStub = nil
	fake.getRepoTreeReturns = struct {
		result1 *githuba.Tree
		result2 error
	}{result1, result2}
}

func (fake *FakeIGithub) GetRepoTreeReturnsOnCall(i int, result1 *githuba.Tree, result2 error) {
	fake.getRepoTreeMutex.Lock()
	defer fake.getRepoTreeMutex.Unlock()
	fake.GetRepoTreeStub = nil
	if fake.getRepoTreeReturnsOnCall == nil {
		fake.getRepoTreeReturnsOnCall = make(map[int]struct {
			result1 *githuba.Tree
			result2 error
		})
	}
	fake.getRepoTreeReturnsOnCall[i] = struct {
		result1 *githuba.Tree
		result2 error
	}{result1, result2}
}

func (fake *FakeIGithub) Post(arg1 string, arg2 url.Values) ([]byte, int, error) {
	fake.postMutex.Lock()
	ret, specificReturn := fake.postReturnsOnCall[len(fake.postArgsForCall)]
	fake.postArgsForCall = append(fake.postArgsForCall, struct {
		arg1 string
		arg2 url.Values
	}{arg1, arg2})
	stub := fake.PostStub
	fakeReturns := fake.postReturns
	fake.recordInvocation("Post", []interface{}{arg1, arg2})
	fake.postMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeIGithub) PostCallCount() int {
	fake.postMutex.RLock()
	defer fake.postMutex.RUnlock()
	return len(fake.postArgsForCall)
}

func (fake *FakeIGithub) PostCalls(stub func(string, url.Values) ([]byte, int, error)) {
	fake.postMutex.Lock()
	defer fake.postMutex.Unlock()
	fake.PostStub = stub
}

func (fake *FakeIGithub) PostArgsForCall(i int) (string, url.Values) {
	fake.postMutex.RLock()
	defer fake.postMutex.RUnlock()
	argsForCall := fake.postArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIGithub) PostReturns(result1 []byte, result2 int, result3 error) {
	fake.postMutex.Lock()
	defer fake.postMutex.Unlock()
	fake.PostStub = nil
	fake.postReturns = struct {
		result1 []byte
		result2 int
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIGithub) PostReturnsOnCall(i int, result1 []byte, result2 int, result3 error) {
	fake.postMutex.Lock()
	defer fake.postMutex.Unlock()
	fake.PostStub = nil
	if fake.postReturnsOnCall == nil {
		fake.postReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 int
			result3 error
		})
	}
	fake.postReturnsOnCall[i] = struct {
		result1 []byte
		result2 int
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeIGithub) UpdateBranch(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 string, arg6 string) (*githuba.Reference, error) {
	fake.updateBranchMutex.Lock()
	ret, specificReturn := fake.updateBranchReturnsOnCall[len(fake.updateBranchArgsForCall)]
	fake.updateBranchArgsForCall = append(fake.updateBranchArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 string
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.UpdateBranchStub
	fakeReturns := fake.updateBranchReturns
	fake.recordInvocation("UpdateBranch", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.updateBranchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIGithub) UpdateBranchCallCount() int {
	fake.updateBranchMutex.RLock()
	defer fake.updateBranchMutex.RUnlock()
	return len(fake.updateBranchArgsForCall)
}

func (fake *FakeIGithub) UpdateBranchCalls(stub func(context.Context, string, string, string, string, string) (*githuba.Reference, error)) {
	fake.updateBranchMutex.Lock()
	defer fake.updateBranchMutex.Unlock()
	fake.UpdateBranchStub = stub
}

func (fake *FakeIGithub) UpdateBranchArgsForCall(i int) (context.Context, string, string, string, string, string) {
	fake.updateBranchMutex.RLock()
	defer fake.updateBranchMutex.RUnlock()
	argsForCall := fake.updateBranchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeIGithub) UpdateBranchReturns(result1 *githuba.Reference, result2 error) {
	fake.updateBranchMutex.Lock()
	defer fake.updateBranchMutex.Unlock()
	fake.UpdateBranchStub = nil
	fake.updateBranchReturns = struct {
		result1 *githuba.Reference
		result2 error
	}{result1, result2}
}

func (fake *FakeIGithub) UpdateBranchReturnsOnCall(i int, result1 *githuba.Reference, result2 error) {
	fake.updateBranchMutex.Lock()
	defer fake.updateBranchMutex.Unlock()
	fake.UpdateBranchStub = nil
	if fake.updateBranchReturnsOnCall == nil {
		fake.updateBranchReturnsOnCall = make(map[int]struct {
			result1 *githuba.Reference
			result2 error
		})
	}
	fake.updateBranchReturnsOnCall[i] = struct {
		result1 *githuba.Reference
		result2 error
	}{result1, result2}
}

func (fake *FakeIGithub) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createBranchMutex.RLock()
	defer fake.createBranchMutex.RUnlock()
	fake.createCommitMutex.RLock()
	defer fake.createCommitMutex.RUnlock()
	fake.createPullRequestMutex.RLock()
	defer fake.createPullRequestMutex.RUnlock()
	fake.createTreeMutex.RLock()
	defer fake.createTreeMutex.RUnlock()
	fake.getRepoArchiveMutex.RLock()
	defer fake.getRepoArchiveMutex.RUnlock()
	fake.getRepoFileMutex.RLock()
	defer fake.getRepoFileMutex.RUnlock()
	fake.getRepoListMutex.RLock()
	defer fake.getRepoListMutex.RUnlock()
	fake.getRepoTreeMutex.RLock()
	defer fake.getRepoTreeMutex.RUnlock()
	fake.postMutex.RLock()
	defer fake.postMutex.RUnlock()
	fake.updateBranchMutex.RLock()
	defer fake.updateBranchMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeIGithub) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ github.IGithub = new(FakeIGithub)
