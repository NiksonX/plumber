// Code generated by counterfeiter. DO NOT EDIT.
package etcdfakes

import (
	"context"
	"sync"

	"github.com/batchcorp/plumber-schemas/build/go/protos"
	"github.com/batchcorp/plumber-schemas/build/go/protos/common"
	"github.com/batchcorp/plumber-schemas/build/go/protos/opts"
	"github.com/batchcorp/plumber/config"
	"github.com/batchcorp/plumber/embed/etcd"
	clientv3 "go.etcd.io/etcd/client/v3"
)

type FakeIEtcd struct {
	BroadcastStub        func(context.Context, *etcd.Message) error
	broadcastMutex       sync.RWMutex
	broadcastArgsForCall []struct {
		arg1 context.Context
		arg2 *etcd.Message
	}
	broadcastReturns struct {
		result1 error
	}
	broadcastReturnsOnCall map[int]struct {
		result1 error
	}
	ClientStub        func() *clientv3.Client
	clientMutex       sync.RWMutex
	clientArgsForCall []struct {
	}
	clientReturns struct {
		result1 *clientv3.Client
	}
	clientReturnsOnCall map[int]struct {
		result1 *clientv3.Client
	}
	DeleteStub        func(context.Context, string, ...clientv3.OpOption) (*clientv3.DeleteResponse, error)
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []clientv3.OpOption
	}
	deleteReturns struct {
		result1 *clientv3.DeleteResponse
		result2 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 *clientv3.DeleteResponse
		result2 error
	}
	DirectStub        func(context.Context, string, *etcd.Message) error
	directMutex       sync.RWMutex
	directArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 *etcd.Message
	}
	directReturns struct {
		result1 error
	}
	directReturnsOnCall map[int]struct {
		result1 error
	}
	GetStub        func(context.Context, string, ...clientv3.OpOption) (*clientv3.GetResponse, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []clientv3.OpOption
	}
	getReturns struct {
		result1 *clientv3.GetResponse
		result2 error
	}
	getReturnsOnCall map[int]struct {
		result1 *clientv3.GetResponse
		result2 error
	}
	PublishConfigUpdateStub        func(context.Context, *etcd.MessageUpdateConfig) error
	publishConfigUpdateMutex       sync.RWMutex
	publishConfigUpdateArgsForCall []struct {
		arg1 context.Context
		arg2 *etcd.MessageUpdateConfig
	}
	publishConfigUpdateReturns struct {
		result1 error
	}
	publishConfigUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	PublishCreateConnectionStub        func(context.Context, *opts.ConnectionOptions) error
	publishCreateConnectionMutex       sync.RWMutex
	publishCreateConnectionArgsForCall []struct {
		arg1 context.Context
		arg2 *opts.ConnectionOptions
	}
	publishCreateConnectionReturns struct {
		result1 error
	}
	publishCreateConnectionReturnsOnCall map[int]struct {
		result1 error
	}
	PublishCreateRelayStub        func(context.Context, *opts.RelayOptions) error
	publishCreateRelayMutex       sync.RWMutex
	publishCreateRelayArgsForCall []struct {
		arg1 context.Context
		arg2 *opts.RelayOptions
	}
	publishCreateRelayReturns struct {
		result1 error
	}
	publishCreateRelayReturnsOnCall map[int]struct {
		result1 error
	}
	PublishCreateSchemaStub        func(context.Context, *protos.Schema) error
	publishCreateSchemaMutex       sync.RWMutex
	publishCreateSchemaArgsForCall []struct {
		arg1 context.Context
		arg2 *protos.Schema
	}
	publishCreateSchemaReturns struct {
		result1 error
	}
	publishCreateSchemaReturnsOnCall map[int]struct {
		result1 error
	}
	PublishCreateServiceStub        func(context.Context, *protos.Service) error
	publishCreateServiceMutex       sync.RWMutex
	publishCreateServiceArgsForCall []struct {
		arg1 context.Context
		arg2 *protos.Service
	}
	publishCreateServiceReturns struct {
		result1 error
	}
	publishCreateServiceReturnsOnCall map[int]struct {
		result1 error
	}
	PublishCreateValidationStub        func(context.Context, *common.Validation) error
	publishCreateValidationMutex       sync.RWMutex
	publishCreateValidationArgsForCall []struct {
		arg1 context.Context
		arg2 *common.Validation
	}
	publishCreateValidationReturns struct {
		result1 error
	}
	publishCreateValidationReturnsOnCall map[int]struct {
		result1 error
	}
	PublishDeleteConnectionStub        func(context.Context, *opts.ConnectionOptions) error
	publishDeleteConnectionMutex       sync.RWMutex
	publishDeleteConnectionArgsForCall []struct {
		arg1 context.Context
		arg2 *opts.ConnectionOptions
	}
	publishDeleteConnectionReturns struct {
		result1 error
	}
	publishDeleteConnectionReturnsOnCall map[int]struct {
		result1 error
	}
	PublishDeleteRelayStub        func(context.Context, *opts.RelayOptions) error
	publishDeleteRelayMutex       sync.RWMutex
	publishDeleteRelayArgsForCall []struct {
		arg1 context.Context
		arg2 *opts.RelayOptions
	}
	publishDeleteRelayReturns struct {
		result1 error
	}
	publishDeleteRelayReturnsOnCall map[int]struct {
		result1 error
	}
	PublishDeleteSchemaStub        func(context.Context, *protos.Schema) error
	publishDeleteSchemaMutex       sync.RWMutex
	publishDeleteSchemaArgsForCall []struct {
		arg1 context.Context
		arg2 *protos.Schema
	}
	publishDeleteSchemaReturns struct {
		result1 error
	}
	publishDeleteSchemaReturnsOnCall map[int]struct {
		result1 error
	}
	PublishDeleteServiceStub        func(context.Context, *protos.Service) error
	publishDeleteServiceMutex       sync.RWMutex
	publishDeleteServiceArgsForCall []struct {
		arg1 context.Context
		arg2 *protos.Service
	}
	publishDeleteServiceReturns struct {
		result1 error
	}
	publishDeleteServiceReturnsOnCall map[int]struct {
		result1 error
	}
	PublishDeleteValidationStub        func(context.Context, *common.Validation) error
	publishDeleteValidationMutex       sync.RWMutex
	publishDeleteValidationArgsForCall []struct {
		arg1 context.Context
		arg2 *common.Validation
	}
	publishDeleteValidationReturns struct {
		result1 error
	}
	publishDeleteValidationReturnsOnCall map[int]struct {
		result1 error
	}
	PublishUpdateConnectionStub        func(context.Context, *opts.ConnectionOptions) error
	publishUpdateConnectionMutex       sync.RWMutex
	publishUpdateConnectionArgsForCall []struct {
		arg1 context.Context
		arg2 *opts.ConnectionOptions
	}
	publishUpdateConnectionReturns struct {
		result1 error
	}
	publishUpdateConnectionReturnsOnCall map[int]struct {
		result1 error
	}
	PublishUpdateRelayStub        func(context.Context, *opts.RelayOptions) error
	publishUpdateRelayMutex       sync.RWMutex
	publishUpdateRelayArgsForCall []struct {
		arg1 context.Context
		arg2 *opts.RelayOptions
	}
	publishUpdateRelayReturns struct {
		result1 error
	}
	publishUpdateRelayReturnsOnCall map[int]struct {
		result1 error
	}
	PublishUpdateSchemaStub        func(context.Context, *protos.Schema) error
	publishUpdateSchemaMutex       sync.RWMutex
	publishUpdateSchemaArgsForCall []struct {
		arg1 context.Context
		arg2 *protos.Schema
	}
	publishUpdateSchemaReturns struct {
		result1 error
	}
	publishUpdateSchemaReturnsOnCall map[int]struct {
		result1 error
	}
	PublishUpdateServiceStub        func(context.Context, *protos.Service) error
	publishUpdateServiceMutex       sync.RWMutex
	publishUpdateServiceArgsForCall []struct {
		arg1 context.Context
		arg2 *protos.Service
	}
	publishUpdateServiceReturns struct {
		result1 error
	}
	publishUpdateServiceReturnsOnCall map[int]struct {
		result1 error
	}
	PublishUpdateValidationStub        func(context.Context, *common.Validation) error
	publishUpdateValidationMutex       sync.RWMutex
	publishUpdateValidationArgsForCall []struct {
		arg1 context.Context
		arg2 *common.Validation
	}
	publishUpdateValidationReturns struct {
		result1 error
	}
	publishUpdateValidationReturnsOnCall map[int]struct {
		result1 error
	}
	PutStub        func(context.Context, string, string, ...clientv3.OpOption) (*clientv3.PutResponse, error)
	putMutex       sync.RWMutex
	putArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 []clientv3.OpOption
	}
	putReturns struct {
		result1 *clientv3.PutResponse
		result2 error
	}
	putReturnsOnCall map[int]struct {
		result1 *clientv3.PutResponse
		result2 error
	}
	SaveConfigStub        func(context.Context, *config.Config) error
	saveConfigMutex       sync.RWMutex
	saveConfigArgsForCall []struct {
		arg1 context.Context
		arg2 *config.Config
	}
	saveConfigReturns struct {
		result1 error
	}
	saveConfigReturnsOnCall map[int]struct {
		result1 error
	}
	ShutdownStub        func(bool) error
	shutdownMutex       sync.RWMutex
	shutdownArgsForCall []struct {
		arg1 bool
	}
	shutdownReturns struct {
		result1 error
	}
	shutdownReturnsOnCall map[int]struct {
		result1 error
	}
	StartStub        func(context.Context) error
	startMutex       sync.RWMutex
	startArgsForCall []struct {
		arg1 context.Context
	}
	startReturns struct {
		result1 error
	}
	startReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeIEtcd) Broadcast(arg1 context.Context, arg2 *etcd.Message) error {
	fake.broadcastMutex.Lock()
	ret, specificReturn := fake.broadcastReturnsOnCall[len(fake.broadcastArgsForCall)]
	fake.broadcastArgsForCall = append(fake.broadcastArgsForCall, struct {
		arg1 context.Context
		arg2 *etcd.Message
	}{arg1, arg2})
	stub := fake.BroadcastStub
	fakeReturns := fake.broadcastReturns
	fake.recordInvocation("Broadcast", []interface{}{arg1, arg2})
	fake.broadcastMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) BroadcastCallCount() int {
	fake.broadcastMutex.RLock()
	defer fake.broadcastMutex.RUnlock()
	return len(fake.broadcastArgsForCall)
}

func (fake *FakeIEtcd) BroadcastCalls(stub func(context.Context, *etcd.Message) error) {
	fake.broadcastMutex.Lock()
	defer fake.broadcastMutex.Unlock()
	fake.BroadcastStub = stub
}

func (fake *FakeIEtcd) BroadcastArgsForCall(i int) (context.Context, *etcd.Message) {
	fake.broadcastMutex.RLock()
	defer fake.broadcastMutex.RUnlock()
	argsForCall := fake.broadcastArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) BroadcastReturns(result1 error) {
	fake.broadcastMutex.Lock()
	defer fake.broadcastMutex.Unlock()
	fake.BroadcastStub = nil
	fake.broadcastReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) BroadcastReturnsOnCall(i int, result1 error) {
	fake.broadcastMutex.Lock()
	defer fake.broadcastMutex.Unlock()
	fake.BroadcastStub = nil
	if fake.broadcastReturnsOnCall == nil {
		fake.broadcastReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.broadcastReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) Client() *clientv3.Client {
	fake.clientMutex.Lock()
	ret, specificReturn := fake.clientReturnsOnCall[len(fake.clientArgsForCall)]
	fake.clientArgsForCall = append(fake.clientArgsForCall, struct {
	}{})
	stub := fake.ClientStub
	fakeReturns := fake.clientReturns
	fake.recordInvocation("Client", []interface{}{})
	fake.clientMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) ClientCallCount() int {
	fake.clientMutex.RLock()
	defer fake.clientMutex.RUnlock()
	return len(fake.clientArgsForCall)
}

func (fake *FakeIEtcd) ClientCalls(stub func() *clientv3.Client) {
	fake.clientMutex.Lock()
	defer fake.clientMutex.Unlock()
	fake.ClientStub = stub
}

func (fake *FakeIEtcd) ClientReturns(result1 *clientv3.Client) {
	fake.clientMutex.Lock()
	defer fake.clientMutex.Unlock()
	fake.ClientStub = nil
	fake.clientReturns = struct {
		result1 *clientv3.Client
	}{result1}
}

func (fake *FakeIEtcd) ClientReturnsOnCall(i int, result1 *clientv3.Client) {
	fake.clientMutex.Lock()
	defer fake.clientMutex.Unlock()
	fake.ClientStub = nil
	if fake.clientReturnsOnCall == nil {
		fake.clientReturnsOnCall = make(map[int]struct {
			result1 *clientv3.Client
		})
	}
	fake.clientReturnsOnCall[i] = struct {
		result1 *clientv3.Client
	}{result1}
}

func (fake *FakeIEtcd) Delete(arg1 context.Context, arg2 string, arg3 ...clientv3.OpOption) (*clientv3.DeleteResponse, error) {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []clientv3.OpOption
	}{arg1, arg2, arg3})
	stub := fake.DeleteStub
	fakeReturns := fake.deleteReturns
	fake.recordInvocation("Delete", []interface{}{arg1, arg2, arg3})
	fake.deleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIEtcd) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeIEtcd) DeleteCalls(stub func(context.Context, string, ...clientv3.OpOption) (*clientv3.DeleteResponse, error)) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *FakeIEtcd) DeleteArgsForCall(i int) (context.Context, string, []clientv3.OpOption) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIEtcd) DeleteReturns(result1 *clientv3.DeleteResponse, result2 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 *clientv3.DeleteResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeIEtcd) DeleteReturnsOnCall(i int, result1 *clientv3.DeleteResponse, result2 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 *clientv3.DeleteResponse
			result2 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 *clientv3.DeleteResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeIEtcd) Direct(arg1 context.Context, arg2 string, arg3 *etcd.Message) error {
	fake.directMutex.Lock()
	ret, specificReturn := fake.directReturnsOnCall[len(fake.directArgsForCall)]
	fake.directArgsForCall = append(fake.directArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 *etcd.Message
	}{arg1, arg2, arg3})
	stub := fake.DirectStub
	fakeReturns := fake.directReturns
	fake.recordInvocation("Direct", []interface{}{arg1, arg2, arg3})
	fake.directMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) DirectCallCount() int {
	fake.directMutex.RLock()
	defer fake.directMutex.RUnlock()
	return len(fake.directArgsForCall)
}

func (fake *FakeIEtcd) DirectCalls(stub func(context.Context, string, *etcd.Message) error) {
	fake.directMutex.Lock()
	defer fake.directMutex.Unlock()
	fake.DirectStub = stub
}

func (fake *FakeIEtcd) DirectArgsForCall(i int) (context.Context, string, *etcd.Message) {
	fake.directMutex.RLock()
	defer fake.directMutex.RUnlock()
	argsForCall := fake.directArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIEtcd) DirectReturns(result1 error) {
	fake.directMutex.Lock()
	defer fake.directMutex.Unlock()
	fake.DirectStub = nil
	fake.directReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) DirectReturnsOnCall(i int, result1 error) {
	fake.directMutex.Lock()
	defer fake.directMutex.Unlock()
	fake.DirectStub = nil
	if fake.directReturnsOnCall == nil {
		fake.directReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.directReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) Get(arg1 context.Context, arg2 string, arg3 ...clientv3.OpOption) (*clientv3.GetResponse, error) {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []clientv3.OpOption
	}{arg1, arg2, arg3})
	stub := fake.GetStub
	fakeReturns := fake.getReturns
	fake.recordInvocation("Get", []interface{}{arg1, arg2, arg3})
	fake.getMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIEtcd) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakeIEtcd) GetCalls(stub func(context.Context, string, ...clientv3.OpOption) (*clientv3.GetResponse, error)) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = stub
}

func (fake *FakeIEtcd) GetArgsForCall(i int) (context.Context, string, []clientv3.OpOption) {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	argsForCall := fake.getArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeIEtcd) GetReturns(result1 *clientv3.GetResponse, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 *clientv3.GetResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeIEtcd) GetReturnsOnCall(i int, result1 *clientv3.GetResponse, result2 error) {
	fake.getMutex.Lock()
	defer fake.getMutex.Unlock()
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 *clientv3.GetResponse
			result2 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 *clientv3.GetResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeIEtcd) PublishConfigUpdate(arg1 context.Context, arg2 *etcd.MessageUpdateConfig) error {
	fake.publishConfigUpdateMutex.Lock()
	ret, specificReturn := fake.publishConfigUpdateReturnsOnCall[len(fake.publishConfigUpdateArgsForCall)]
	fake.publishConfigUpdateArgsForCall = append(fake.publishConfigUpdateArgsForCall, struct {
		arg1 context.Context
		arg2 *etcd.MessageUpdateConfig
	}{arg1, arg2})
	stub := fake.PublishConfigUpdateStub
	fakeReturns := fake.publishConfigUpdateReturns
	fake.recordInvocation("PublishConfigUpdate", []interface{}{arg1, arg2})
	fake.publishConfigUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishConfigUpdateCallCount() int {
	fake.publishConfigUpdateMutex.RLock()
	defer fake.publishConfigUpdateMutex.RUnlock()
	return len(fake.publishConfigUpdateArgsForCall)
}

func (fake *FakeIEtcd) PublishConfigUpdateCalls(stub func(context.Context, *etcd.MessageUpdateConfig) error) {
	fake.publishConfigUpdateMutex.Lock()
	defer fake.publishConfigUpdateMutex.Unlock()
	fake.PublishConfigUpdateStub = stub
}

func (fake *FakeIEtcd) PublishConfigUpdateArgsForCall(i int) (context.Context, *etcd.MessageUpdateConfig) {
	fake.publishConfigUpdateMutex.RLock()
	defer fake.publishConfigUpdateMutex.RUnlock()
	argsForCall := fake.publishConfigUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishConfigUpdateReturns(result1 error) {
	fake.publishConfigUpdateMutex.Lock()
	defer fake.publishConfigUpdateMutex.Unlock()
	fake.PublishConfigUpdateStub = nil
	fake.publishConfigUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishConfigUpdateReturnsOnCall(i int, result1 error) {
	fake.publishConfigUpdateMutex.Lock()
	defer fake.publishConfigUpdateMutex.Unlock()
	fake.PublishConfigUpdateStub = nil
	if fake.publishConfigUpdateReturnsOnCall == nil {
		fake.publishConfigUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishConfigUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishCreateConnection(arg1 context.Context, arg2 *opts.ConnectionOptions) error {
	fake.publishCreateConnectionMutex.Lock()
	ret, specificReturn := fake.publishCreateConnectionReturnsOnCall[len(fake.publishCreateConnectionArgsForCall)]
	fake.publishCreateConnectionArgsForCall = append(fake.publishCreateConnectionArgsForCall, struct {
		arg1 context.Context
		arg2 *opts.ConnectionOptions
	}{arg1, arg2})
	stub := fake.PublishCreateConnectionStub
	fakeReturns := fake.publishCreateConnectionReturns
	fake.recordInvocation("PublishCreateConnection", []interface{}{arg1, arg2})
	fake.publishCreateConnectionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishCreateConnectionCallCount() int {
	fake.publishCreateConnectionMutex.RLock()
	defer fake.publishCreateConnectionMutex.RUnlock()
	return len(fake.publishCreateConnectionArgsForCall)
}

func (fake *FakeIEtcd) PublishCreateConnectionCalls(stub func(context.Context, *opts.ConnectionOptions) error) {
	fake.publishCreateConnectionMutex.Lock()
	defer fake.publishCreateConnectionMutex.Unlock()
	fake.PublishCreateConnectionStub = stub
}

func (fake *FakeIEtcd) PublishCreateConnectionArgsForCall(i int) (context.Context, *opts.ConnectionOptions) {
	fake.publishCreateConnectionMutex.RLock()
	defer fake.publishCreateConnectionMutex.RUnlock()
	argsForCall := fake.publishCreateConnectionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishCreateConnectionReturns(result1 error) {
	fake.publishCreateConnectionMutex.Lock()
	defer fake.publishCreateConnectionMutex.Unlock()
	fake.PublishCreateConnectionStub = nil
	fake.publishCreateConnectionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishCreateConnectionReturnsOnCall(i int, result1 error) {
	fake.publishCreateConnectionMutex.Lock()
	defer fake.publishCreateConnectionMutex.Unlock()
	fake.PublishCreateConnectionStub = nil
	if fake.publishCreateConnectionReturnsOnCall == nil {
		fake.publishCreateConnectionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishCreateConnectionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishCreateRelay(arg1 context.Context, arg2 *opts.RelayOptions) error {
	fake.publishCreateRelayMutex.Lock()
	ret, specificReturn := fake.publishCreateRelayReturnsOnCall[len(fake.publishCreateRelayArgsForCall)]
	fake.publishCreateRelayArgsForCall = append(fake.publishCreateRelayArgsForCall, struct {
		arg1 context.Context
		arg2 *opts.RelayOptions
	}{arg1, arg2})
	stub := fake.PublishCreateRelayStub
	fakeReturns := fake.publishCreateRelayReturns
	fake.recordInvocation("PublishCreateRelay", []interface{}{arg1, arg2})
	fake.publishCreateRelayMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishCreateRelayCallCount() int {
	fake.publishCreateRelayMutex.RLock()
	defer fake.publishCreateRelayMutex.RUnlock()
	return len(fake.publishCreateRelayArgsForCall)
}

func (fake *FakeIEtcd) PublishCreateRelayCalls(stub func(context.Context, *opts.RelayOptions) error) {
	fake.publishCreateRelayMutex.Lock()
	defer fake.publishCreateRelayMutex.Unlock()
	fake.PublishCreateRelayStub = stub
}

func (fake *FakeIEtcd) PublishCreateRelayArgsForCall(i int) (context.Context, *opts.RelayOptions) {
	fake.publishCreateRelayMutex.RLock()
	defer fake.publishCreateRelayMutex.RUnlock()
	argsForCall := fake.publishCreateRelayArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishCreateRelayReturns(result1 error) {
	fake.publishCreateRelayMutex.Lock()
	defer fake.publishCreateRelayMutex.Unlock()
	fake.PublishCreateRelayStub = nil
	fake.publishCreateRelayReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishCreateRelayReturnsOnCall(i int, result1 error) {
	fake.publishCreateRelayMutex.Lock()
	defer fake.publishCreateRelayMutex.Unlock()
	fake.PublishCreateRelayStub = nil
	if fake.publishCreateRelayReturnsOnCall == nil {
		fake.publishCreateRelayReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishCreateRelayReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishCreateSchema(arg1 context.Context, arg2 *protos.Schema) error {
	fake.publishCreateSchemaMutex.Lock()
	ret, specificReturn := fake.publishCreateSchemaReturnsOnCall[len(fake.publishCreateSchemaArgsForCall)]
	fake.publishCreateSchemaArgsForCall = append(fake.publishCreateSchemaArgsForCall, struct {
		arg1 context.Context
		arg2 *protos.Schema
	}{arg1, arg2})
	stub := fake.PublishCreateSchemaStub
	fakeReturns := fake.publishCreateSchemaReturns
	fake.recordInvocation("PublishCreateSchema", []interface{}{arg1, arg2})
	fake.publishCreateSchemaMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishCreateSchemaCallCount() int {
	fake.publishCreateSchemaMutex.RLock()
	defer fake.publishCreateSchemaMutex.RUnlock()
	return len(fake.publishCreateSchemaArgsForCall)
}

func (fake *FakeIEtcd) PublishCreateSchemaCalls(stub func(context.Context, *protos.Schema) error) {
	fake.publishCreateSchemaMutex.Lock()
	defer fake.publishCreateSchemaMutex.Unlock()
	fake.PublishCreateSchemaStub = stub
}

func (fake *FakeIEtcd) PublishCreateSchemaArgsForCall(i int) (context.Context, *protos.Schema) {
	fake.publishCreateSchemaMutex.RLock()
	defer fake.publishCreateSchemaMutex.RUnlock()
	argsForCall := fake.publishCreateSchemaArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishCreateSchemaReturns(result1 error) {
	fake.publishCreateSchemaMutex.Lock()
	defer fake.publishCreateSchemaMutex.Unlock()
	fake.PublishCreateSchemaStub = nil
	fake.publishCreateSchemaReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishCreateSchemaReturnsOnCall(i int, result1 error) {
	fake.publishCreateSchemaMutex.Lock()
	defer fake.publishCreateSchemaMutex.Unlock()
	fake.PublishCreateSchemaStub = nil
	if fake.publishCreateSchemaReturnsOnCall == nil {
		fake.publishCreateSchemaReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishCreateSchemaReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishCreateService(arg1 context.Context, arg2 *protos.Service) error {
	fake.publishCreateServiceMutex.Lock()
	ret, specificReturn := fake.publishCreateServiceReturnsOnCall[len(fake.publishCreateServiceArgsForCall)]
	fake.publishCreateServiceArgsForCall = append(fake.publishCreateServiceArgsForCall, struct {
		arg1 context.Context
		arg2 *protos.Service
	}{arg1, arg2})
	stub := fake.PublishCreateServiceStub
	fakeReturns := fake.publishCreateServiceReturns
	fake.recordInvocation("PublishCreateService", []interface{}{arg1, arg2})
	fake.publishCreateServiceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishCreateServiceCallCount() int {
	fake.publishCreateServiceMutex.RLock()
	defer fake.publishCreateServiceMutex.RUnlock()
	return len(fake.publishCreateServiceArgsForCall)
}

func (fake *FakeIEtcd) PublishCreateServiceCalls(stub func(context.Context, *protos.Service) error) {
	fake.publishCreateServiceMutex.Lock()
	defer fake.publishCreateServiceMutex.Unlock()
	fake.PublishCreateServiceStub = stub
}

func (fake *FakeIEtcd) PublishCreateServiceArgsForCall(i int) (context.Context, *protos.Service) {
	fake.publishCreateServiceMutex.RLock()
	defer fake.publishCreateServiceMutex.RUnlock()
	argsForCall := fake.publishCreateServiceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishCreateServiceReturns(result1 error) {
	fake.publishCreateServiceMutex.Lock()
	defer fake.publishCreateServiceMutex.Unlock()
	fake.PublishCreateServiceStub = nil
	fake.publishCreateServiceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishCreateServiceReturnsOnCall(i int, result1 error) {
	fake.publishCreateServiceMutex.Lock()
	defer fake.publishCreateServiceMutex.Unlock()
	fake.PublishCreateServiceStub = nil
	if fake.publishCreateServiceReturnsOnCall == nil {
		fake.publishCreateServiceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishCreateServiceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishCreateValidation(arg1 context.Context, arg2 *common.Validation) error {
	fake.publishCreateValidationMutex.Lock()
	ret, specificReturn := fake.publishCreateValidationReturnsOnCall[len(fake.publishCreateValidationArgsForCall)]
	fake.publishCreateValidationArgsForCall = append(fake.publishCreateValidationArgsForCall, struct {
		arg1 context.Context
		arg2 *common.Validation
	}{arg1, arg2})
	stub := fake.PublishCreateValidationStub
	fakeReturns := fake.publishCreateValidationReturns
	fake.recordInvocation("PublishCreateValidation", []interface{}{arg1, arg2})
	fake.publishCreateValidationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishCreateValidationCallCount() int {
	fake.publishCreateValidationMutex.RLock()
	defer fake.publishCreateValidationMutex.RUnlock()
	return len(fake.publishCreateValidationArgsForCall)
}

func (fake *FakeIEtcd) PublishCreateValidationCalls(stub func(context.Context, *common.Validation) error) {
	fake.publishCreateValidationMutex.Lock()
	defer fake.publishCreateValidationMutex.Unlock()
	fake.PublishCreateValidationStub = stub
}

func (fake *FakeIEtcd) PublishCreateValidationArgsForCall(i int) (context.Context, *common.Validation) {
	fake.publishCreateValidationMutex.RLock()
	defer fake.publishCreateValidationMutex.RUnlock()
	argsForCall := fake.publishCreateValidationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishCreateValidationReturns(result1 error) {
	fake.publishCreateValidationMutex.Lock()
	defer fake.publishCreateValidationMutex.Unlock()
	fake.PublishCreateValidationStub = nil
	fake.publishCreateValidationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishCreateValidationReturnsOnCall(i int, result1 error) {
	fake.publishCreateValidationMutex.Lock()
	defer fake.publishCreateValidationMutex.Unlock()
	fake.PublishCreateValidationStub = nil
	if fake.publishCreateValidationReturnsOnCall == nil {
		fake.publishCreateValidationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishCreateValidationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishDeleteConnection(arg1 context.Context, arg2 *opts.ConnectionOptions) error {
	fake.publishDeleteConnectionMutex.Lock()
	ret, specificReturn := fake.publishDeleteConnectionReturnsOnCall[len(fake.publishDeleteConnectionArgsForCall)]
	fake.publishDeleteConnectionArgsForCall = append(fake.publishDeleteConnectionArgsForCall, struct {
		arg1 context.Context
		arg2 *opts.ConnectionOptions
	}{arg1, arg2})
	stub := fake.PublishDeleteConnectionStub
	fakeReturns := fake.publishDeleteConnectionReturns
	fake.recordInvocation("PublishDeleteConnection", []interface{}{arg1, arg2})
	fake.publishDeleteConnectionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishDeleteConnectionCallCount() int {
	fake.publishDeleteConnectionMutex.RLock()
	defer fake.publishDeleteConnectionMutex.RUnlock()
	return len(fake.publishDeleteConnectionArgsForCall)
}

func (fake *FakeIEtcd) PublishDeleteConnectionCalls(stub func(context.Context, *opts.ConnectionOptions) error) {
	fake.publishDeleteConnectionMutex.Lock()
	defer fake.publishDeleteConnectionMutex.Unlock()
	fake.PublishDeleteConnectionStub = stub
}

func (fake *FakeIEtcd) PublishDeleteConnectionArgsForCall(i int) (context.Context, *opts.ConnectionOptions) {
	fake.publishDeleteConnectionMutex.RLock()
	defer fake.publishDeleteConnectionMutex.RUnlock()
	argsForCall := fake.publishDeleteConnectionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishDeleteConnectionReturns(result1 error) {
	fake.publishDeleteConnectionMutex.Lock()
	defer fake.publishDeleteConnectionMutex.Unlock()
	fake.PublishDeleteConnectionStub = nil
	fake.publishDeleteConnectionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishDeleteConnectionReturnsOnCall(i int, result1 error) {
	fake.publishDeleteConnectionMutex.Lock()
	defer fake.publishDeleteConnectionMutex.Unlock()
	fake.PublishDeleteConnectionStub = nil
	if fake.publishDeleteConnectionReturnsOnCall == nil {
		fake.publishDeleteConnectionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishDeleteConnectionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishDeleteRelay(arg1 context.Context, arg2 *opts.RelayOptions) error {
	fake.publishDeleteRelayMutex.Lock()
	ret, specificReturn := fake.publishDeleteRelayReturnsOnCall[len(fake.publishDeleteRelayArgsForCall)]
	fake.publishDeleteRelayArgsForCall = append(fake.publishDeleteRelayArgsForCall, struct {
		arg1 context.Context
		arg2 *opts.RelayOptions
	}{arg1, arg2})
	stub := fake.PublishDeleteRelayStub
	fakeReturns := fake.publishDeleteRelayReturns
	fake.recordInvocation("PublishDeleteRelay", []interface{}{arg1, arg2})
	fake.publishDeleteRelayMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishDeleteRelayCallCount() int {
	fake.publishDeleteRelayMutex.RLock()
	defer fake.publishDeleteRelayMutex.RUnlock()
	return len(fake.publishDeleteRelayArgsForCall)
}

func (fake *FakeIEtcd) PublishDeleteRelayCalls(stub func(context.Context, *opts.RelayOptions) error) {
	fake.publishDeleteRelayMutex.Lock()
	defer fake.publishDeleteRelayMutex.Unlock()
	fake.PublishDeleteRelayStub = stub
}

func (fake *FakeIEtcd) PublishDeleteRelayArgsForCall(i int) (context.Context, *opts.RelayOptions) {
	fake.publishDeleteRelayMutex.RLock()
	defer fake.publishDeleteRelayMutex.RUnlock()
	argsForCall := fake.publishDeleteRelayArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishDeleteRelayReturns(result1 error) {
	fake.publishDeleteRelayMutex.Lock()
	defer fake.publishDeleteRelayMutex.Unlock()
	fake.PublishDeleteRelayStub = nil
	fake.publishDeleteRelayReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishDeleteRelayReturnsOnCall(i int, result1 error) {
	fake.publishDeleteRelayMutex.Lock()
	defer fake.publishDeleteRelayMutex.Unlock()
	fake.PublishDeleteRelayStub = nil
	if fake.publishDeleteRelayReturnsOnCall == nil {
		fake.publishDeleteRelayReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishDeleteRelayReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishDeleteSchema(arg1 context.Context, arg2 *protos.Schema) error {
	fake.publishDeleteSchemaMutex.Lock()
	ret, specificReturn := fake.publishDeleteSchemaReturnsOnCall[len(fake.publishDeleteSchemaArgsForCall)]
	fake.publishDeleteSchemaArgsForCall = append(fake.publishDeleteSchemaArgsForCall, struct {
		arg1 context.Context
		arg2 *protos.Schema
	}{arg1, arg2})
	stub := fake.PublishDeleteSchemaStub
	fakeReturns := fake.publishDeleteSchemaReturns
	fake.recordInvocation("PublishDeleteSchema", []interface{}{arg1, arg2})
	fake.publishDeleteSchemaMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishDeleteSchemaCallCount() int {
	fake.publishDeleteSchemaMutex.RLock()
	defer fake.publishDeleteSchemaMutex.RUnlock()
	return len(fake.publishDeleteSchemaArgsForCall)
}

func (fake *FakeIEtcd) PublishDeleteSchemaCalls(stub func(context.Context, *protos.Schema) error) {
	fake.publishDeleteSchemaMutex.Lock()
	defer fake.publishDeleteSchemaMutex.Unlock()
	fake.PublishDeleteSchemaStub = stub
}

func (fake *FakeIEtcd) PublishDeleteSchemaArgsForCall(i int) (context.Context, *protos.Schema) {
	fake.publishDeleteSchemaMutex.RLock()
	defer fake.publishDeleteSchemaMutex.RUnlock()
	argsForCall := fake.publishDeleteSchemaArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishDeleteSchemaReturns(result1 error) {
	fake.publishDeleteSchemaMutex.Lock()
	defer fake.publishDeleteSchemaMutex.Unlock()
	fake.PublishDeleteSchemaStub = nil
	fake.publishDeleteSchemaReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishDeleteSchemaReturnsOnCall(i int, result1 error) {
	fake.publishDeleteSchemaMutex.Lock()
	defer fake.publishDeleteSchemaMutex.Unlock()
	fake.PublishDeleteSchemaStub = nil
	if fake.publishDeleteSchemaReturnsOnCall == nil {
		fake.publishDeleteSchemaReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishDeleteSchemaReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishDeleteService(arg1 context.Context, arg2 *protos.Service) error {
	fake.publishDeleteServiceMutex.Lock()
	ret, specificReturn := fake.publishDeleteServiceReturnsOnCall[len(fake.publishDeleteServiceArgsForCall)]
	fake.publishDeleteServiceArgsForCall = append(fake.publishDeleteServiceArgsForCall, struct {
		arg1 context.Context
		arg2 *protos.Service
	}{arg1, arg2})
	stub := fake.PublishDeleteServiceStub
	fakeReturns := fake.publishDeleteServiceReturns
	fake.recordInvocation("PublishDeleteService", []interface{}{arg1, arg2})
	fake.publishDeleteServiceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishDeleteServiceCallCount() int {
	fake.publishDeleteServiceMutex.RLock()
	defer fake.publishDeleteServiceMutex.RUnlock()
	return len(fake.publishDeleteServiceArgsForCall)
}

func (fake *FakeIEtcd) PublishDeleteServiceCalls(stub func(context.Context, *protos.Service) error) {
	fake.publishDeleteServiceMutex.Lock()
	defer fake.publishDeleteServiceMutex.Unlock()
	fake.PublishDeleteServiceStub = stub
}

func (fake *FakeIEtcd) PublishDeleteServiceArgsForCall(i int) (context.Context, *protos.Service) {
	fake.publishDeleteServiceMutex.RLock()
	defer fake.publishDeleteServiceMutex.RUnlock()
	argsForCall := fake.publishDeleteServiceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishDeleteServiceReturns(result1 error) {
	fake.publishDeleteServiceMutex.Lock()
	defer fake.publishDeleteServiceMutex.Unlock()
	fake.PublishDeleteServiceStub = nil
	fake.publishDeleteServiceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishDeleteServiceReturnsOnCall(i int, result1 error) {
	fake.publishDeleteServiceMutex.Lock()
	defer fake.publishDeleteServiceMutex.Unlock()
	fake.PublishDeleteServiceStub = nil
	if fake.publishDeleteServiceReturnsOnCall == nil {
		fake.publishDeleteServiceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishDeleteServiceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishDeleteValidation(arg1 context.Context, arg2 *common.Validation) error {
	fake.publishDeleteValidationMutex.Lock()
	ret, specificReturn := fake.publishDeleteValidationReturnsOnCall[len(fake.publishDeleteValidationArgsForCall)]
	fake.publishDeleteValidationArgsForCall = append(fake.publishDeleteValidationArgsForCall, struct {
		arg1 context.Context
		arg2 *common.Validation
	}{arg1, arg2})
	stub := fake.PublishDeleteValidationStub
	fakeReturns := fake.publishDeleteValidationReturns
	fake.recordInvocation("PublishDeleteValidation", []interface{}{arg1, arg2})
	fake.publishDeleteValidationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishDeleteValidationCallCount() int {
	fake.publishDeleteValidationMutex.RLock()
	defer fake.publishDeleteValidationMutex.RUnlock()
	return len(fake.publishDeleteValidationArgsForCall)
}

func (fake *FakeIEtcd) PublishDeleteValidationCalls(stub func(context.Context, *common.Validation) error) {
	fake.publishDeleteValidationMutex.Lock()
	defer fake.publishDeleteValidationMutex.Unlock()
	fake.PublishDeleteValidationStub = stub
}

func (fake *FakeIEtcd) PublishDeleteValidationArgsForCall(i int) (context.Context, *common.Validation) {
	fake.publishDeleteValidationMutex.RLock()
	defer fake.publishDeleteValidationMutex.RUnlock()
	argsForCall := fake.publishDeleteValidationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishDeleteValidationReturns(result1 error) {
	fake.publishDeleteValidationMutex.Lock()
	defer fake.publishDeleteValidationMutex.Unlock()
	fake.PublishDeleteValidationStub = nil
	fake.publishDeleteValidationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishDeleteValidationReturnsOnCall(i int, result1 error) {
	fake.publishDeleteValidationMutex.Lock()
	defer fake.publishDeleteValidationMutex.Unlock()
	fake.PublishDeleteValidationStub = nil
	if fake.publishDeleteValidationReturnsOnCall == nil {
		fake.publishDeleteValidationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishDeleteValidationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishUpdateConnection(arg1 context.Context, arg2 *opts.ConnectionOptions) error {
	fake.publishUpdateConnectionMutex.Lock()
	ret, specificReturn := fake.publishUpdateConnectionReturnsOnCall[len(fake.publishUpdateConnectionArgsForCall)]
	fake.publishUpdateConnectionArgsForCall = append(fake.publishUpdateConnectionArgsForCall, struct {
		arg1 context.Context
		arg2 *opts.ConnectionOptions
	}{arg1, arg2})
	stub := fake.PublishUpdateConnectionStub
	fakeReturns := fake.publishUpdateConnectionReturns
	fake.recordInvocation("PublishUpdateConnection", []interface{}{arg1, arg2})
	fake.publishUpdateConnectionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishUpdateConnectionCallCount() int {
	fake.publishUpdateConnectionMutex.RLock()
	defer fake.publishUpdateConnectionMutex.RUnlock()
	return len(fake.publishUpdateConnectionArgsForCall)
}

func (fake *FakeIEtcd) PublishUpdateConnectionCalls(stub func(context.Context, *opts.ConnectionOptions) error) {
	fake.publishUpdateConnectionMutex.Lock()
	defer fake.publishUpdateConnectionMutex.Unlock()
	fake.PublishUpdateConnectionStub = stub
}

func (fake *FakeIEtcd) PublishUpdateConnectionArgsForCall(i int) (context.Context, *opts.ConnectionOptions) {
	fake.publishUpdateConnectionMutex.RLock()
	defer fake.publishUpdateConnectionMutex.RUnlock()
	argsForCall := fake.publishUpdateConnectionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishUpdateConnectionReturns(result1 error) {
	fake.publishUpdateConnectionMutex.Lock()
	defer fake.publishUpdateConnectionMutex.Unlock()
	fake.PublishUpdateConnectionStub = nil
	fake.publishUpdateConnectionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishUpdateConnectionReturnsOnCall(i int, result1 error) {
	fake.publishUpdateConnectionMutex.Lock()
	defer fake.publishUpdateConnectionMutex.Unlock()
	fake.PublishUpdateConnectionStub = nil
	if fake.publishUpdateConnectionReturnsOnCall == nil {
		fake.publishUpdateConnectionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishUpdateConnectionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishUpdateRelay(arg1 context.Context, arg2 *opts.RelayOptions) error {
	fake.publishUpdateRelayMutex.Lock()
	ret, specificReturn := fake.publishUpdateRelayReturnsOnCall[len(fake.publishUpdateRelayArgsForCall)]
	fake.publishUpdateRelayArgsForCall = append(fake.publishUpdateRelayArgsForCall, struct {
		arg1 context.Context
		arg2 *opts.RelayOptions
	}{arg1, arg2})
	stub := fake.PublishUpdateRelayStub
	fakeReturns := fake.publishUpdateRelayReturns
	fake.recordInvocation("PublishUpdateRelay", []interface{}{arg1, arg2})
	fake.publishUpdateRelayMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishUpdateRelayCallCount() int {
	fake.publishUpdateRelayMutex.RLock()
	defer fake.publishUpdateRelayMutex.RUnlock()
	return len(fake.publishUpdateRelayArgsForCall)
}

func (fake *FakeIEtcd) PublishUpdateRelayCalls(stub func(context.Context, *opts.RelayOptions) error) {
	fake.publishUpdateRelayMutex.Lock()
	defer fake.publishUpdateRelayMutex.Unlock()
	fake.PublishUpdateRelayStub = stub
}

func (fake *FakeIEtcd) PublishUpdateRelayArgsForCall(i int) (context.Context, *opts.RelayOptions) {
	fake.publishUpdateRelayMutex.RLock()
	defer fake.publishUpdateRelayMutex.RUnlock()
	argsForCall := fake.publishUpdateRelayArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishUpdateRelayReturns(result1 error) {
	fake.publishUpdateRelayMutex.Lock()
	defer fake.publishUpdateRelayMutex.Unlock()
	fake.PublishUpdateRelayStub = nil
	fake.publishUpdateRelayReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishUpdateRelayReturnsOnCall(i int, result1 error) {
	fake.publishUpdateRelayMutex.Lock()
	defer fake.publishUpdateRelayMutex.Unlock()
	fake.PublishUpdateRelayStub = nil
	if fake.publishUpdateRelayReturnsOnCall == nil {
		fake.publishUpdateRelayReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishUpdateRelayReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishUpdateSchema(arg1 context.Context, arg2 *protos.Schema) error {
	fake.publishUpdateSchemaMutex.Lock()
	ret, specificReturn := fake.publishUpdateSchemaReturnsOnCall[len(fake.publishUpdateSchemaArgsForCall)]
	fake.publishUpdateSchemaArgsForCall = append(fake.publishUpdateSchemaArgsForCall, struct {
		arg1 context.Context
		arg2 *protos.Schema
	}{arg1, arg2})
	stub := fake.PublishUpdateSchemaStub
	fakeReturns := fake.publishUpdateSchemaReturns
	fake.recordInvocation("PublishUpdateSchema", []interface{}{arg1, arg2})
	fake.publishUpdateSchemaMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishUpdateSchemaCallCount() int {
	fake.publishUpdateSchemaMutex.RLock()
	defer fake.publishUpdateSchemaMutex.RUnlock()
	return len(fake.publishUpdateSchemaArgsForCall)
}

func (fake *FakeIEtcd) PublishUpdateSchemaCalls(stub func(context.Context, *protos.Schema) error) {
	fake.publishUpdateSchemaMutex.Lock()
	defer fake.publishUpdateSchemaMutex.Unlock()
	fake.PublishUpdateSchemaStub = stub
}

func (fake *FakeIEtcd) PublishUpdateSchemaArgsForCall(i int) (context.Context, *protos.Schema) {
	fake.publishUpdateSchemaMutex.RLock()
	defer fake.publishUpdateSchemaMutex.RUnlock()
	argsForCall := fake.publishUpdateSchemaArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishUpdateSchemaReturns(result1 error) {
	fake.publishUpdateSchemaMutex.Lock()
	defer fake.publishUpdateSchemaMutex.Unlock()
	fake.PublishUpdateSchemaStub = nil
	fake.publishUpdateSchemaReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishUpdateSchemaReturnsOnCall(i int, result1 error) {
	fake.publishUpdateSchemaMutex.Lock()
	defer fake.publishUpdateSchemaMutex.Unlock()
	fake.PublishUpdateSchemaStub = nil
	if fake.publishUpdateSchemaReturnsOnCall == nil {
		fake.publishUpdateSchemaReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishUpdateSchemaReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishUpdateService(arg1 context.Context, arg2 *protos.Service) error {
	fake.publishUpdateServiceMutex.Lock()
	ret, specificReturn := fake.publishUpdateServiceReturnsOnCall[len(fake.publishUpdateServiceArgsForCall)]
	fake.publishUpdateServiceArgsForCall = append(fake.publishUpdateServiceArgsForCall, struct {
		arg1 context.Context
		arg2 *protos.Service
	}{arg1, arg2})
	stub := fake.PublishUpdateServiceStub
	fakeReturns := fake.publishUpdateServiceReturns
	fake.recordInvocation("PublishUpdateService", []interface{}{arg1, arg2})
	fake.publishUpdateServiceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishUpdateServiceCallCount() int {
	fake.publishUpdateServiceMutex.RLock()
	defer fake.publishUpdateServiceMutex.RUnlock()
	return len(fake.publishUpdateServiceArgsForCall)
}

func (fake *FakeIEtcd) PublishUpdateServiceCalls(stub func(context.Context, *protos.Service) error) {
	fake.publishUpdateServiceMutex.Lock()
	defer fake.publishUpdateServiceMutex.Unlock()
	fake.PublishUpdateServiceStub = stub
}

func (fake *FakeIEtcd) PublishUpdateServiceArgsForCall(i int) (context.Context, *protos.Service) {
	fake.publishUpdateServiceMutex.RLock()
	defer fake.publishUpdateServiceMutex.RUnlock()
	argsForCall := fake.publishUpdateServiceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishUpdateServiceReturns(result1 error) {
	fake.publishUpdateServiceMutex.Lock()
	defer fake.publishUpdateServiceMutex.Unlock()
	fake.PublishUpdateServiceStub = nil
	fake.publishUpdateServiceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishUpdateServiceReturnsOnCall(i int, result1 error) {
	fake.publishUpdateServiceMutex.Lock()
	defer fake.publishUpdateServiceMutex.Unlock()
	fake.PublishUpdateServiceStub = nil
	if fake.publishUpdateServiceReturnsOnCall == nil {
		fake.publishUpdateServiceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishUpdateServiceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishUpdateValidation(arg1 context.Context, arg2 *common.Validation) error {
	fake.publishUpdateValidationMutex.Lock()
	ret, specificReturn := fake.publishUpdateValidationReturnsOnCall[len(fake.publishUpdateValidationArgsForCall)]
	fake.publishUpdateValidationArgsForCall = append(fake.publishUpdateValidationArgsForCall, struct {
		arg1 context.Context
		arg2 *common.Validation
	}{arg1, arg2})
	stub := fake.PublishUpdateValidationStub
	fakeReturns := fake.publishUpdateValidationReturns
	fake.recordInvocation("PublishUpdateValidation", []interface{}{arg1, arg2})
	fake.publishUpdateValidationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) PublishUpdateValidationCallCount() int {
	fake.publishUpdateValidationMutex.RLock()
	defer fake.publishUpdateValidationMutex.RUnlock()
	return len(fake.publishUpdateValidationArgsForCall)
}

func (fake *FakeIEtcd) PublishUpdateValidationCalls(stub func(context.Context, *common.Validation) error) {
	fake.publishUpdateValidationMutex.Lock()
	defer fake.publishUpdateValidationMutex.Unlock()
	fake.PublishUpdateValidationStub = stub
}

func (fake *FakeIEtcd) PublishUpdateValidationArgsForCall(i int) (context.Context, *common.Validation) {
	fake.publishUpdateValidationMutex.RLock()
	defer fake.publishUpdateValidationMutex.RUnlock()
	argsForCall := fake.publishUpdateValidationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) PublishUpdateValidationReturns(result1 error) {
	fake.publishUpdateValidationMutex.Lock()
	defer fake.publishUpdateValidationMutex.Unlock()
	fake.PublishUpdateValidationStub = nil
	fake.publishUpdateValidationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) PublishUpdateValidationReturnsOnCall(i int, result1 error) {
	fake.publishUpdateValidationMutex.Lock()
	defer fake.publishUpdateValidationMutex.Unlock()
	fake.PublishUpdateValidationStub = nil
	if fake.publishUpdateValidationReturnsOnCall == nil {
		fake.publishUpdateValidationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.publishUpdateValidationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) Put(arg1 context.Context, arg2 string, arg3 string, arg4 ...clientv3.OpOption) (*clientv3.PutResponse, error) {
	fake.putMutex.Lock()
	ret, specificReturn := fake.putReturnsOnCall[len(fake.putArgsForCall)]
	fake.putArgsForCall = append(fake.putArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 []clientv3.OpOption
	}{arg1, arg2, arg3, arg4})
	stub := fake.PutStub
	fakeReturns := fake.putReturns
	fake.recordInvocation("Put", []interface{}{arg1, arg2, arg3, arg4})
	fake.putMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeIEtcd) PutCallCount() int {
	fake.putMutex.RLock()
	defer fake.putMutex.RUnlock()
	return len(fake.putArgsForCall)
}

func (fake *FakeIEtcd) PutCalls(stub func(context.Context, string, string, ...clientv3.OpOption) (*clientv3.PutResponse, error)) {
	fake.putMutex.Lock()
	defer fake.putMutex.Unlock()
	fake.PutStub = stub
}

func (fake *FakeIEtcd) PutArgsForCall(i int) (context.Context, string, string, []clientv3.OpOption) {
	fake.putMutex.RLock()
	defer fake.putMutex.RUnlock()
	argsForCall := fake.putArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeIEtcd) PutReturns(result1 *clientv3.PutResponse, result2 error) {
	fake.putMutex.Lock()
	defer fake.putMutex.Unlock()
	fake.PutStub = nil
	fake.putReturns = struct {
		result1 *clientv3.PutResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeIEtcd) PutReturnsOnCall(i int, result1 *clientv3.PutResponse, result2 error) {
	fake.putMutex.Lock()
	defer fake.putMutex.Unlock()
	fake.PutStub = nil
	if fake.putReturnsOnCall == nil {
		fake.putReturnsOnCall = make(map[int]struct {
			result1 *clientv3.PutResponse
			result2 error
		})
	}
	fake.putReturnsOnCall[i] = struct {
		result1 *clientv3.PutResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeIEtcd) SaveConfig(arg1 context.Context, arg2 *config.Config) error {
	fake.saveConfigMutex.Lock()
	ret, specificReturn := fake.saveConfigReturnsOnCall[len(fake.saveConfigArgsForCall)]
	fake.saveConfigArgsForCall = append(fake.saveConfigArgsForCall, struct {
		arg1 context.Context
		arg2 *config.Config
	}{arg1, arg2})
	stub := fake.SaveConfigStub
	fakeReturns := fake.saveConfigReturns
	fake.recordInvocation("SaveConfig", []interface{}{arg1, arg2})
	fake.saveConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) SaveConfigCallCount() int {
	fake.saveConfigMutex.RLock()
	defer fake.saveConfigMutex.RUnlock()
	return len(fake.saveConfigArgsForCall)
}

func (fake *FakeIEtcd) SaveConfigCalls(stub func(context.Context, *config.Config) error) {
	fake.saveConfigMutex.Lock()
	defer fake.saveConfigMutex.Unlock()
	fake.SaveConfigStub = stub
}

func (fake *FakeIEtcd) SaveConfigArgsForCall(i int) (context.Context, *config.Config) {
	fake.saveConfigMutex.RLock()
	defer fake.saveConfigMutex.RUnlock()
	argsForCall := fake.saveConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeIEtcd) SaveConfigReturns(result1 error) {
	fake.saveConfigMutex.Lock()
	defer fake.saveConfigMutex.Unlock()
	fake.SaveConfigStub = nil
	fake.saveConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) SaveConfigReturnsOnCall(i int, result1 error) {
	fake.saveConfigMutex.Lock()
	defer fake.saveConfigMutex.Unlock()
	fake.SaveConfigStub = nil
	if fake.saveConfigReturnsOnCall == nil {
		fake.saveConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) Shutdown(arg1 bool) error {
	fake.shutdownMutex.Lock()
	ret, specificReturn := fake.shutdownReturnsOnCall[len(fake.shutdownArgsForCall)]
	fake.shutdownArgsForCall = append(fake.shutdownArgsForCall, struct {
		arg1 bool
	}{arg1})
	stub := fake.ShutdownStub
	fakeReturns := fake.shutdownReturns
	fake.recordInvocation("Shutdown", []interface{}{arg1})
	fake.shutdownMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) ShutdownCallCount() int {
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	return len(fake.shutdownArgsForCall)
}

func (fake *FakeIEtcd) ShutdownCalls(stub func(bool) error) {
	fake.shutdownMutex.Lock()
	defer fake.shutdownMutex.Unlock()
	fake.ShutdownStub = stub
}

func (fake *FakeIEtcd) ShutdownArgsForCall(i int) bool {
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	argsForCall := fake.shutdownArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIEtcd) ShutdownReturns(result1 error) {
	fake.shutdownMutex.Lock()
	defer fake.shutdownMutex.Unlock()
	fake.ShutdownStub = nil
	fake.shutdownReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) ShutdownReturnsOnCall(i int, result1 error) {
	fake.shutdownMutex.Lock()
	defer fake.shutdownMutex.Unlock()
	fake.ShutdownStub = nil
	if fake.shutdownReturnsOnCall == nil {
		fake.shutdownReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.shutdownReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) Start(arg1 context.Context) error {
	fake.startMutex.Lock()
	ret, specificReturn := fake.startReturnsOnCall[len(fake.startArgsForCall)]
	fake.startArgsForCall = append(fake.startArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.StartStub
	fakeReturns := fake.startReturns
	fake.recordInvocation("Start", []interface{}{arg1})
	fake.startMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeIEtcd) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeIEtcd) StartCalls(stub func(context.Context) error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = stub
}

func (fake *FakeIEtcd) StartArgsForCall(i int) context.Context {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	argsForCall := fake.startArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeIEtcd) StartReturns(result1 error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = nil
	fake.startReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) StartReturnsOnCall(i int, result1 error) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = nil
	if fake.startReturnsOnCall == nil {
		fake.startReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeIEtcd) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.broadcastMutex.RLock()
	defer fake.broadcastMutex.RUnlock()
	fake.clientMutex.RLock()
	defer fake.clientMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.directMutex.RLock()
	defer fake.directMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.publishConfigUpdateMutex.RLock()
	defer fake.publishConfigUpdateMutex.RUnlock()
	fake.publishCreateConnectionMutex.RLock()
	defer fake.publishCreateConnectionMutex.RUnlock()
	fake.publishCreateRelayMutex.RLock()
	defer fake.publishCreateRelayMutex.RUnlock()
	fake.publishCreateSchemaMutex.RLock()
	defer fake.publishCreateSchemaMutex.RUnlock()
	fake.publishCreateServiceMutex.RLock()
	defer fake.publishCreateServiceMutex.RUnlock()
	fake.publishCreateValidationMutex.RLock()
	defer fake.publishCreateValidationMutex.RUnlock()
	fake.publishDeleteConnectionMutex.RLock()
	defer fake.publishDeleteConnectionMutex.RUnlock()
	fake.publishDeleteRelayMutex.RLock()
	defer fake.publishDeleteRelayMutex.RUnlock()
	fake.publishDeleteSchemaMutex.RLock()
	defer fake.publishDeleteSchemaMutex.RUnlock()
	fake.publishDeleteServiceMutex.RLock()
	defer fake.publishDeleteServiceMutex.RUnlock()
	fake.publishDeleteValidationMutex.RLock()
	defer fake.publishDeleteValidationMutex.RUnlock()
	fake.publishUpdateConnectionMutex.RLock()
	defer fake.publishUpdateConnectionMutex.RUnlock()
	fake.publishUpdateRelayMutex.RLock()
	defer fake.publishUpdateRelayMutex.RUnlock()
	fake.publishUpdateSchemaMutex.RLock()
	defer fake.publishUpdateSchemaMutex.RUnlock()
	fake.publishUpdateServiceMutex.RLock()
	defer fake.publishUpdateServiceMutex.RUnlock()
	fake.publishUpdateValidationMutex.RLock()
	defer fake.publishUpdateValidationMutex.RUnlock()
	fake.putMutex.RLock()
	defer fake.putMutex.RUnlock()
	fake.saveConfigMutex.RLock()
	defer fake.saveConfigMutex.RUnlock()
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeIEtcd) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ etcd.IEtcd = new(FakeIEtcd)
