// Code generated by protoc-gen-go. DO NOT EDIT.
// source: replay.proto

package events

import (
	fmt "fmt"
	destinations "github.com/batchcorp/schemas/build/go/events/destinations"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Replay_Type int32

const (
	Replay_UNSET      Replay_Type = 0
	Replay_ONETIME    Replay_Type = 1
	Replay_CONTINUOUS Replay_Type = 2
)

var Replay_Type_name = map[int32]string{
	0: "UNSET",
	1: "ONETIME",
	2: "CONTINUOUS",
}

var Replay_Type_value = map[string]int32{
	"UNSET":      0,
	"ONETIME":    1,
	"CONTINUOUS": 2,
}

func (x Replay_Type) String() string {
	return proto.EnumName(Replay_Type_name, int32(x))
}

func (Replay_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eed9461330ccfc03, []int{0, 0}
}

type Replay struct {
	// Replay id in DB
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Filter is used by the search service to find fitting events and pushing
	// them to HSB for consumption by the replay service.
	Filter *Filter `protobuf:"bytes,2,opt,name=filter,proto3" json:"filter,omitempty"`
	// Used by reader to know which index to use
	CollectId string `protobuf:"bytes,3,opt,name=collect_id,json=collectId,proto3" json:"collect_id,omitempty"`
	// Emitted by reader via an UPDATE_SCHEMA message
	// Consumed by ui-bff for storage to perform a replay redo
	// Consumed by reader in a CREATE_SCHEMA message in order to perform a replay redo
	QueryExecutionId string `protobuf:"bytes,4,opt,name=query_execution_id,json=queryExecutionId,proto3" json:"query_execution_id,omitempty"`
	// Used by reader and replayer to know if this replay is continuous or not
	Type Replay_Type `protobuf:"varint,5,opt,name=type,proto3,enum=events.Replay_Type" json:"type,omitempty"`
	// Used by the replay service
	//
	// Types that are valid to be assigned to Dst:
	//	*Replay_Http
	//	*Replay_Sqs
	//	*Replay_Amqp
	//	*Replay_Kafka
	//	*Replay_RedisPubsub
	//	*Replay_RedisStreams
	//	*Replay_Dynamic
	//	*Replay_Nsq
	Dst                  isReplay_Dst `protobuf_oneof:"dst"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Replay) Reset()         { *m = Replay{} }
func (m *Replay) String() string { return proto.CompactTextString(m) }
func (*Replay) ProtoMessage()    {}
func (*Replay) Descriptor() ([]byte, []int) {
	return fileDescriptor_eed9461330ccfc03, []int{0}
}

func (m *Replay) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Replay.Unmarshal(m, b)
}
func (m *Replay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Replay.Marshal(b, m, deterministic)
}
func (m *Replay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Replay.Merge(m, src)
}
func (m *Replay) XXX_Size() int {
	return xxx_messageInfo_Replay.Size(m)
}
func (m *Replay) XXX_DiscardUnknown() {
	xxx_messageInfo_Replay.DiscardUnknown(m)
}

var xxx_messageInfo_Replay proto.InternalMessageInfo

func (m *Replay) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Replay) GetFilter() *Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *Replay) GetCollectId() string {
	if m != nil {
		return m.CollectId
	}
	return ""
}

func (m *Replay) GetQueryExecutionId() string {
	if m != nil {
		return m.QueryExecutionId
	}
	return ""
}

func (m *Replay) GetType() Replay_Type {
	if m != nil {
		return m.Type
	}
	return Replay_UNSET
}

type isReplay_Dst interface {
	isReplay_Dst()
}

type Replay_Http struct {
	Http *destinations.HTTP `protobuf:"bytes,100,opt,name=http,proto3,oneof"`
}

type Replay_Sqs struct {
	Sqs *destinations.SQS `protobuf:"bytes,101,opt,name=sqs,proto3,oneof"`
}

type Replay_Amqp struct {
	Amqp *destinations.AMQP `protobuf:"bytes,102,opt,name=amqp,proto3,oneof"`
}

type Replay_Kafka struct {
	Kafka *destinations.Kafka `protobuf:"bytes,103,opt,name=kafka,proto3,oneof"`
}

type Replay_RedisPubsub struct {
	RedisPubsub *destinations.RedisPubsub `protobuf:"bytes,104,opt,name=redis_pubsub,json=redisPubsub,proto3,oneof"`
}

type Replay_RedisStreams struct {
	RedisStreams *destinations.RedisStreams `protobuf:"bytes,105,opt,name=redis_streams,json=redisStreams,proto3,oneof"`
}

type Replay_Dynamic struct {
	Dynamic *destinations.Dynamic `protobuf:"bytes,106,opt,name=dynamic,proto3,oneof"`
}

type Replay_Nsq struct {
	Nsq *destinations.NSQ `protobuf:"bytes,107,opt,name=nsq,proto3,oneof"`
}

func (*Replay_Http) isReplay_Dst() {}

func (*Replay_Sqs) isReplay_Dst() {}

func (*Replay_Amqp) isReplay_Dst() {}

func (*Replay_Kafka) isReplay_Dst() {}

func (*Replay_RedisPubsub) isReplay_Dst() {}

func (*Replay_RedisStreams) isReplay_Dst() {}

func (*Replay_Dynamic) isReplay_Dst() {}

func (*Replay_Nsq) isReplay_Dst() {}

func (m *Replay) GetDst() isReplay_Dst {
	if m != nil {
		return m.Dst
	}
	return nil
}

func (m *Replay) GetHttp() *destinations.HTTP {
	if x, ok := m.GetDst().(*Replay_Http); ok {
		return x.Http
	}
	return nil
}

func (m *Replay) GetSqs() *destinations.SQS {
	if x, ok := m.GetDst().(*Replay_Sqs); ok {
		return x.Sqs
	}
	return nil
}

func (m *Replay) GetAmqp() *destinations.AMQP {
	if x, ok := m.GetDst().(*Replay_Amqp); ok {
		return x.Amqp
	}
	return nil
}

func (m *Replay) GetKafka() *destinations.Kafka {
	if x, ok := m.GetDst().(*Replay_Kafka); ok {
		return x.Kafka
	}
	return nil
}

func (m *Replay) GetRedisPubsub() *destinations.RedisPubsub {
	if x, ok := m.GetDst().(*Replay_RedisPubsub); ok {
		return x.RedisPubsub
	}
	return nil
}

func (m *Replay) GetRedisStreams() *destinations.RedisStreams {
	if x, ok := m.GetDst().(*Replay_RedisStreams); ok {
		return x.RedisStreams
	}
	return nil
}

func (m *Replay) GetDynamic() *destinations.Dynamic {
	if x, ok := m.GetDst().(*Replay_Dynamic); ok {
		return x.Dynamic
	}
	return nil
}

func (m *Replay) GetNsq() *destinations.NSQ {
	if x, ok := m.GetDst().(*Replay_Nsq); ok {
		return x.Nsq
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Replay) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Replay_Http)(nil),
		(*Replay_Sqs)(nil),
		(*Replay_Amqp)(nil),
		(*Replay_Kafka)(nil),
		(*Replay_RedisPubsub)(nil),
		(*Replay_RedisStreams)(nil),
		(*Replay_Dynamic)(nil),
		(*Replay_Nsq)(nil),
	}
}

func init() {
	proto.RegisterEnum("events.Replay_Type", Replay_Type_name, Replay_Type_value)
	proto.RegisterType((*Replay)(nil), "events.Replay")
}

func init() { proto.RegisterFile("replay.proto", fileDescriptor_eed9461330ccfc03) }

var fileDescriptor_eed9461330ccfc03 = []byte{
	// 506 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x92, 0x5f, 0x8b, 0xd3, 0x40,
	0x14, 0xc5, 0xd3, 0xbf, 0x4b, 0xa7, 0x6b, 0xa9, 0xb3, 0xa8, 0x63, 0x41, 0x2c, 0x0b, 0x6a, 0xc1,
	0x35, 0xc1, 0xf5, 0x5d, 0xd8, 0xd5, 0x4a, 0x8a, 0x6c, 0xbb, 0x9d, 0xa4, 0x2f, 0xbe, 0x94, 0x24,
	0x33, 0x6d, 0xc7, 0xe6, 0xff, 0x4c, 0xc4, 0x7c, 0x6d, 0x3f, 0x81, 0xcc, 0x4c, 0x82, 0x06, 0xf2,
	0x98, 0x7b, 0x7e, 0xe7, 0xde, 0xc9, 0x3d, 0x17, 0x5c, 0xe6, 0x34, 0x0d, 0xbd, 0xd2, 0x4c, 0xf3,
	0x44, 0x24, 0x70, 0x48, 0x7f, 0xd1, 0x58, 0xf0, 0xd9, 0xe5, 0x81, 0x85, 0x82, 0xe6, 0xba, 0x3a,
	0x7b, 0x41, 0x28, 0x17, 0x2c, 0xf6, 0x04, 0x4b, 0x62, 0x6e, 0x9d, 0x84, 0x48, 0x2b, 0xe1, 0x79,
	0x43, 0xe0, 0x19, 0x6f, 0x35, 0x78, 0x51, 0x56, 0x1b, 0x50, 0x43, 0x38, 0x7b, 0x87, 0xb3, 0x57,
	0x29, 0xaf, 0x1b, 0x4a, 0x4e, 0x09, 0xe3, 0x1f, 0xd2, 0xc2, 0xe7, 0x85, 0x5f, 0x01, 0xf3, 0x16,
	0x80, 0x8b, 0x9c, 0x7a, 0x51, 0x3d, 0x75, 0xd6, 0x20, 0x48, 0x19, 0x7b, 0x11, 0x0b, 0x5a, 0x5f,
	0x1a, 0xf3, 0x4c, 0xd7, 0xaf, 0xff, 0xf4, 0xc1, 0x10, 0xab, 0x0d, 0xc0, 0x09, 0xe8, 0x32, 0x82,
	0x3a, 0xf3, 0xce, 0x62, 0x84, 0xbb, 0x8c, 0xc0, 0xb7, 0x60, 0xa8, 0xb7, 0x80, 0xba, 0xf3, 0xce,
	0x62, 0x7c, 0x3b, 0x31, 0xf5, 0x72, 0xcc, 0x6f, 0xaa, 0x8a, 0x2b, 0x15, 0xbe, 0x02, 0x20, 0x48,
	0xc2, 0x90, 0x06, 0x62, 0xcf, 0x08, 0xea, 0x29, 0xff, 0xa8, 0xaa, 0xac, 0x08, 0xbc, 0x01, 0x30,
	0x2b, 0x68, 0x5e, 0xee, 0xe9, 0x6f, 0x1a, 0x14, 0x72, 0xbe, 0xc4, 0xfa, 0x0a, 0x9b, 0x2a, 0x65,
	0x59, 0x0b, 0x2b, 0x02, 0xdf, 0x81, 0xbe, 0x28, 0x53, 0x8a, 0x06, 0xf3, 0xce, 0x62, 0x72, 0x7b,
	0x55, 0x8f, 0xd4, 0x4f, 0x34, 0xdd, 0x32, 0xa5, 0x58, 0x01, 0x70, 0x01, 0xfa, 0x32, 0x08, 0x44,
	0xd4, 0xdb, 0xa0, 0xf9, 0xff, 0xff, 0x99, 0xb6, 0xeb, 0x3e, 0xda, 0x06, 0x56, 0x04, 0x7c, 0x03,
	0x7a, 0x3c, 0xe3, 0x88, 0x2a, 0xf0, 0x69, 0x13, 0x74, 0xb6, 0x8e, 0x6d, 0x60, 0xa9, 0xcb, 0x86,
	0x32, 0x28, 0x74, 0x68, 0x6b, 0x78, 0xf7, 0xb0, 0x55, 0x0d, 0x25, 0x01, 0xdf, 0x83, 0x81, 0x4a,
	0x0e, 0x1d, 0x15, 0x7a, 0xd5, 0x44, 0xbf, 0x4b, 0xc9, 0x36, 0xb0, 0x66, 0xe0, 0x67, 0x79, 0x61,
	0x84, 0xf1, 0xbd, 0x0e, 0x13, 0x9d, 0x94, 0xe7, 0x65, 0xd3, 0x83, 0x25, 0xf1, 0xa8, 0x00, 0xdb,
	0xc0, 0xe3, 0xfc, 0xdf, 0x27, 0xbc, 0x03, 0x4f, 0xb4, 0xbf, 0xca, 0x1a, 0x31, 0xd5, 0x60, 0xd6,
	0xd2, 0xc0, 0xd1, 0x84, 0x6d, 0x60, 0x3d, 0xb2, 0xfa, 0x86, 0x1f, 0xc1, 0x45, 0x75, 0x0c, 0xe8,
	0xa7, 0x32, 0x3f, 0x6b, 0x9a, 0xbf, 0x6a, 0xd1, 0x36, 0x70, 0xcd, 0xc9, 0x9d, 0xc5, 0x3c, 0x43,
	0xe7, 0xb6, 0x9d, 0xad, 0x9d, 0xad, 0xdc, 0x59, 0xcc, 0xb3, 0x6b, 0x13, 0xf4, 0x65, 0x24, 0x70,
	0x04, 0x06, 0xbb, 0xb5, 0xb3, 0x74, 0xa7, 0x06, 0x1c, 0x83, 0x8b, 0xcd, 0x7a, 0xe9, 0xae, 0x1e,
	0x96, 0xd3, 0x0e, 0x9c, 0x00, 0xf0, 0x65, 0xb3, 0x76, 0x57, 0xeb, 0xdd, 0x66, 0xe7, 0x4c, 0xbb,
	0xf7, 0x03, 0xd0, 0x23, 0x5c, 0xdc, 0x9b, 0x3f, 0x6e, 0x8e, 0x4c, 0x9c, 0x0a, 0xdf, 0x0c, 0x92,
	0xc8, 0xf2, 0x3d, 0x11, 0x9c, 0x82, 0x24, 0x4f, 0x2d, 0x1e, 0x9c, 0x68, 0xe4, 0x71, 0xcb, 0x2f,
	0x58, 0x48, 0xac, 0x63, 0x62, 0xe9, 0xf4, 0xfd, 0xa1, 0xba, 0xd5, 0x4f, 0x7f, 0x03, 0x00, 0x00,
	0xff, 0xff, 0xf1, 0xd2, 0xf2, 0x07, 0xac, 0x03, 0x00, 0x00,
}
